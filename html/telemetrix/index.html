<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>telemetrix.telemetrix API documentation</title>
<meta name="description" content="Copyright (c) 2020 Alan Yorinks All rights reserved â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>telemetrix.telemetrix</code></h1>
</header>
<section id="section-intro">
<p>Copyright (c) 2020 Alan Yorinks All rights reserved.</p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
Version 3 as published by the Free Software Foundation; either
or (at your option) any later version.
This library is distributed in the hope that it will be useful,f
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU
General Public License for more details.</p>
<p>You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
02110-1301
USA</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
 Copyright (c) 2020 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,f
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

&#34;&#34;&#34;
import socket
import sys
import threading
import time
from collections import deque

import serial
# noinspection PyPackageRequirementscd
from serial.serialutil import SerialException
# noinspection PyPackageRequirements
from serial.tools import list_ports

# noinspection PyUnresolvedReferences
from telemetrix.private_constants import PrivateConstants


# noinspection PyPep8,PyMethodMayBeStatic,GrazieInspection,PyBroadException
class Telemetrix(threading.Thread):
    &#34;&#34;&#34;
    This class exposes and implements the telemetrix API.
    It uses threading to accommodate concurrency.
    It includes the public API methods as well as
    a set of private methods.

    &#34;&#34;&#34;

    # noinspection PyPep8,PyPep8,PyPep8
    def __init__(self, com_port=None, arduino_instance_id=1,
                 arduino_wait=4, sleep_tune=0.000001,
                 shutdown_on_exception=True,
                 ip_address=None, ip_port=31335):

        &#34;&#34;&#34;

        :param com_port: e.g. COM3 or /dev/ttyACM0.
                         Only use if you wish to bypass auto com port
                         detection.

        :param arduino_instance_id: Match with the value installed on the
                                    arduino-telemetrix sketch.

        :param arduino_wait: Amount of time to wait for an Arduino to
                             fully reset itself.

        :param sleep_tune: A tuning parameter (typically not changed by user)

        :param shutdown_on_exception: call shutdown before raising
                                      a RunTimeError exception, or
                                      receiving a KeyboardInterrupt exception

        :param ip_address: ip address of tcp/ip connected device.

        :param ip_port: ip port of tcp/ip connected device
        &#34;&#34;&#34;

        # initialize threading parent
        threading.Thread.__init__(self)

        # create the threads and set them as daemons so
        # that they stop when the program is closed

        # create a thread to interpret received serial data
        self.the_reporter_thread = threading.Thread(target=self._reporter)
        self.the_reporter_thread.daemon = True

        self.ip_address = ip_address
        self.ip_port = ip_port

        if not self.ip_address:
            self.the_data_receive_thread = threading.Thread(target=self._serial_receiver)
        else:
            self.the_data_receive_thread = threading.Thread(target=self._tcp_receiver)

        self.the_data_receive_thread.daemon = True

        # flag to allow the reporter and receive threads to run.
        self.run_event = threading.Event()

        # check to make sure that Python interpreter is version 3.7 or greater
        python_version = sys.version_info
        if python_version[0] &gt;= 3:
            if python_version[1] &gt;= 7:
                pass
            else:
                raise RuntimeError(&#34;ERROR: Python 3.7 or greater is &#34;
                                   &#34;required for use of this program.&#34;)

        # save input parameters as instance variables
        self.com_port = com_port
        self.arduino_instance_id = arduino_instance_id
        self.arduino_wait = arduino_wait
        self.sleep_tune = sleep_tune
        self.shutdown_on_exception = shutdown_on_exception

        # create a deque to receive and process data from the arduino
        self.the_deque = deque()

        # The report_dispatch dictionary is used to process
        # incoming report messages by looking up the report message
        # and executing its associated processing method.

        self.report_dispatch = {}

        # To add a command to the command dispatch table, append here.
        self.report_dispatch.update(
            {PrivateConstants.LOOP_COMMAND: self._report_loop_data})
        self.report_dispatch.update(
            {PrivateConstants.DEBUG_PRINT: self._report_debug_data})
        self.report_dispatch.update(
            {PrivateConstants.DIGITAL_REPORT: self._digital_message})
        self.report_dispatch.update(
            {PrivateConstants.ANALOG_REPORT: self._analog_message})
        self.report_dispatch.update(
            {PrivateConstants.FIRMWARE_REPORT: self._firmware_message})
        self.report_dispatch.update({PrivateConstants.I_AM_HERE_REPORT: self._i_am_here})
        self.report_dispatch.update(
            {PrivateConstants.SERVO_UNAVAILABLE: self._servo_unavailable})
        self.report_dispatch.update(
            {PrivateConstants.I2C_READ_REPORT: self._i2c_read_report})
        self.report_dispatch.update(
            {PrivateConstants.I2C_TOO_FEW_BYTES_RCVD: self._i2c_too_few})
        self.report_dispatch.update(
            {PrivateConstants.I2C_TOO_MANY_BYTES_RCVD: self._i2c_too_many})
        self.report_dispatch.update(
            {PrivateConstants.SONAR_DISTANCE: self._sonar_distance_report})
        self.report_dispatch.update({PrivateConstants.DHT_REPORT: self._dht_report})
        self.report_dispatch.update(
            {PrivateConstants.SPI_REPORT: self._spi_report})
        self.report_dispatch.update(
            {PrivateConstants.ONE_WIRE_REPORT: self._onewire_report})

        # dictionaries to store the callbacks for each pin
        self.analog_callbacks = {}

        self.digital_callbacks = {}

        self.i2c_callback = None
        self.i2c_callback2 = None

        self.i2c_1_active = False
        self.i2c_2_active = False

        self.spi_callback = None

        self.onewire_callback = None

        self.cs_pins_enabled = []

        # the trigger pin will be the key to retrieve
        # the callback for a specific HC-SR04
        self.sonar_callbacks = {}

        self.sonar_count = 0

        self.dht_callbacks = {}

        self.dht_count = 0

        # serial port in use
        self.serial_port = None

        # socket for tcp/ip communications
        self.sock = None

        # flag to indicate we are in shutdown mode
        self.shutdown_flag = False

        # debug loopback callback method
        self.loop_back_callback = None

        # flag to indicate the start of a new report
        # self.new_report_start = True

        # firmware version to be stored here
        self.firmware_version = []

        # reported arduino instance id
        self.reported_arduino_id = []

        # flag to indicate if i2c was previously enabled
        self.i2c_enabled = False

        # flag to indicate if spi is initialized
        self.spi_enabled = False

        # flag to indicate if onewire is initialized
        self.onewire_enabled = False

        self.the_reporter_thread.start()
        self.the_data_receive_thread.start()

        print(f&#34;Telemetrix:  Version {PrivateConstants.TELEMETRIX_VERSION}\n\n&#34;
              f&#34;Copyright (c) 2020 Alan Yorinks All Rights Reserved.\n&#34;)

        # using the serial link
        if not self.ip_address:
            if not self.com_port:
                # user did not specify a com_port
                try:
                    self._find_arduino()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        self.shutdown()
            else:
                # com_port specified - set com_port and baud rate
                try:
                    self._manual_open()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        self.shutdown()

            if self.serial_port:
                print(
                    f&#34;Arduino compatible device found and connected to {self.serial_port.port}&#34;)

                self.serial_port.reset_input_buffer()
                self.serial_port.reset_output_buffer()

            # no com_port found - raise a runtime exception
            else:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)
        else:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.ip_address, self.ip_port))
            print(f&#39;Successfully connected to: {self.ip_address}:{self.ip_port}&#39;)

        # allow the threads to run
        self._run_threads()
        print(f&#39;Waiting for Arduino to reset&#39;)
        print(f&#39;Reset Complete&#39;)

        print(&#39;Retrieving Arduino ID...&#39;)
        self._get_arduino_id()
        if self.reported_arduino_id != self.arduino_instance_id:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;Incorrect Arduino ID: {self.reported_arduino_id}&#39;)
        print(&#39;Valid Arduino ID Found.&#39;)
        # get telemetrix firmware version and print it
        print(&#39;\nRetrieving Telemetrix4Arduino firmware ID...&#39;)
        self._get_firmware_version()
        if not self.firmware_version:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;Telemetrix4Arduino firmware version&#39;)

        else:
            print(f&#39;Telemetrix4Arduino firmware version: {self.firmware_version[0]}.&#39;
                  f&#39;{self.firmware_version[1]}.{self.firmware_version[2]}&#39;)
        command = [PrivateConstants.ENABLE_ALL_REPORTS]
        self._send_command(command)

        # Have the server reset its data structures
        command = [PrivateConstants.RESET]
        self._send_command(command)

    def _find_arduino(self):
        &#34;&#34;&#34;
        This method will search all potential serial ports for an Arduino
        containing a sketch that has a matching arduino_instance_id as
        specified in the input parameters of this class.

        This is used explicitly with the Telemetrix4Arduino sketch.
        &#34;&#34;&#34;

        # a list of serial ports to be checked
        serial_ports = []

        print(&#39;Opening all potential serial ports...&#39;)
        the_ports_list = list_ports.comports()
        for port in the_ports_list:
            if port.pid is None:
                continue
            try:
                self.serial_port = serial.Serial(port.device, 115200,
                                                 timeout=1, writeTimeout=0)
            except SerialException:
                continue
            # create a list of serial ports that we opened
            serial_ports.append(self.serial_port)

            # display to the user
            print(&#39;\t&#39; + port.device)

            # clear out any possible data in the input buffer
        # wait for arduino to reset
        print(
            f&#39;\nWaiting {self.arduino_wait} seconds(arduino_wait) for Arduino devices to &#39;
            &#39;reset...&#39;)
        # temporary for testing
        time.sleep(self.arduino_wait)

        # check for correct arduino device
        self.serial_port.reset_input_buffer()
        self.serial_port.reset_output_buffer()

    def _manual_open(self):
        &#34;&#34;&#34;
        Com port was specified by the user - try to open up that port

        &#34;&#34;&#34;
        # if port is not found, a serial exception will be thrown
        try:
            print(f&#39;Opening {self.com_port}...&#39;)
            self.serial_port = serial.Serial(self.com_port, 115200,
                                             timeout=1, writeTimeout=0)

            print(
                f&#39;\nWaiting {self.arduino_wait} seconds(arduino_wait) for Arduino devices to &#39;
                &#39;reset...&#39;)
            self._run_threads()
            time.sleep(self.arduino_wait)

            self._get_arduino_id()

            if self.reported_arduino_id != self.arduino_instance_id:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(f&#39;Incorrect Arduino ID: {self.reported_arduino_id}&#39;)
            print(&#39;Valid Arduino ID Found.&#39;)
            # get arduino firmware version and print it
            print(&#39;\nRetrieving Telemetrix4Arduino firmware ID...&#39;)
            self._get_firmware_version()

            if not self.firmware_version:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    f&#39;Telemetrix4Arduino Sketch Firmware Version Not Found&#39;)

            else:
                print(f&#39;Telemetrix4Arduino firmware version: {self.firmware_version[0]}.&#39;
                      f&#39;{self.firmware_version[1]}&#39;)
        except KeyboardInterrupt:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;User Hit Control-C&#39;)

    def analog_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: arduino pin number

        :param value: pin value (maximum 16 bits)

        &#34;&#34;&#34;
        value_msb = value &gt;&gt; 8
        value_lsb = value &amp; 0xff
        command = [PrivateConstants.ANALOG_WRITE, pin, value_msb, value_lsb]
        self._send_command(command)

    def digital_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: arduino pin number

        :param value: pin value (1 or 0)

        &#34;&#34;&#34;

        command = [PrivateConstants.DIGITAL_WRITE, pin, value]
        self._send_command(command)

    def disable_all_reporting(self):
        &#34;&#34;&#34;
        Disable reporting for all digital and analog input pins
        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DISABLE_ALL, 0]
        self._send_command(command)

    def disable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Disables analog reporting for a single analog pin.

        :param pin: Analog pin number. For example for A0, the number is 0.

        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_ANALOG_DISABLE, pin]
        self._send_command(command)

    def disable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Disables digital reporting for a single digital input.

        :param pin: Pin number.

        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DIGITAL_DISABLE, pin]
        self._send_command(command)

    def enable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Enables analog reporting for the specified pin.

        :param pin: Analog pin number. For example for A0, the number is 0.


        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_ANALOG_ENABLE, pin]
        self._send_command(command)

    def enable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Enable reporting on the specified digital pin.

        :param pin: Pin number.
        &#34;&#34;&#34;

        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DIGITAL_ENABLE, pin]
        self._send_command(command)

    def _get_arduino_id(self):
        &#34;&#34;&#34;
        Retrieve arduino-telemetrix arduino id

        &#34;&#34;&#34;
        command = [PrivateConstants.ARE_U_THERE]
        self._send_command(command)
        # provide time for the reply
        time.sleep(.5)

    def _get_firmware_version(self):
        &#34;&#34;&#34;
        This method retrieves the
        arduino-telemetrix firmware version

        &#34;&#34;&#34;
        command = [PrivateConstants.GET_FIRMWARE_VERSION]
        self._send_command(command)
        # provide time for the reply
        time.sleep(.5)

    def i2c_read(self, address, register, number_of_bytes,
                 callback=None, i2c_port=0):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Required callback function to report i2c data as a
                   result of read command

       :param i2c_port: 0 = default, 1 = secondary


        callback returns a data list:
        [I2C_READ_REPORT, address, register, count of data bytes, data bytes, time-stamp]

        &#34;&#34;&#34;

        self._i2c_read_request(address, register, number_of_bytes,
                               callback=callback, i2c_port=i2c_port)

    def i2c_read_restart_transmission(self, address, register,
                                      number_of_bytes,
                                      callback=None, i2c_port=0):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device. This restarts the transmission after the read. It is
        required for some i2c devices such as the MMA8452Q accelerometer.


        :param address: i2c device address

        :param register: i2c register (or None if no register
                                                    selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Required callback function to report i2c data as a
                   result of read command

       :param i2c_port: 0 = default 1 = secondary


        callback returns a data list:

        [I2C_READ_REPORT, address, register, count of data bytes, data bytes, time-stamp]

        &#34;&#34;&#34;

        self._i2c_read_request(address, register, number_of_bytes,
                               stop_transmission=False,
                               callback=callback, i2c_port=i2c_port)

    def _i2c_read_request(self, address, register, number_of_bytes,
                          stop_transmission=True, callback=None, i2c_port=0):
        &#34;&#34;&#34;
        This method requests the read of an i2c device. Results are retrieved
        via callback.

        :param address: i2c device address

        :param register: register number (or None if no register selection is needed)

        :param number_of_bytes: number of bytes expected to be returned

        :param stop_transmission: stop transmission after read

        :param callback: Required callback function to report i2c data as a
                   result of read command.

        &#34;&#34;&#34;
        if not i2c_port:
            if not self.i2c_1_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Read: set_pin_mode i2c never called for i2c port 1.&#39;)

        if i2c_port:
            if not self.i2c_2_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Read: set_pin_mode i2c never called for i2c port 2.&#39;)

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;I2C Read: A callback function must be specified.&#39;)

        if not i2c_port:
            self.i2c_callback = callback
        else:
            self.i2c_callback2 = callback

        if not register:
            register = 0

        # message contains:
        # 1. address
        # 2. register
        # 3. number of bytes
        # 4. restart_transmission - True or False
        # 5. i2c port

        command = [PrivateConstants.I2C_READ, address, register, number_of_bytes,
                   stop_transmission, i2c_port]
        self._send_command(command)

    def i2c_write(self, address, args, i2c_port=0):
        &#34;&#34;&#34;
        Write data to an i2c device.

        :param address: i2c device address

        :param i2c_port: 0= port 1, 1 = port 2

        :param args: A variable number of bytes to be sent to the device
                     passed in as a list

        &#34;&#34;&#34;
        if not i2c_port:
            if not self.i2c_1_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode i2c never called for i2c port 1.&#39;)

        if i2c_port:
            if not self.i2c_2_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode i2c never called for i2c port 2.&#39;)

        command = [PrivateConstants.I2C_WRITE, len(args), address, i2c_port]

        for item in args:
            command.append(item)

        self._send_command(command)

    def loop_back(self, start_character, callback=None):
        &#34;&#34;&#34;
        This is a debugging method to send a character to the
        Arduino device, and have the device loop it back.

        :param start_character: The character to loop back. It should be
                                an integer.

        :param callback: Looped back character will appear in the callback method

        &#34;&#34;&#34;
        command = [PrivateConstants.LOOP_COMMAND, ord(start_character)]
        self.loop_back_callback = callback
        self._send_command(command)

    def set_analog_scan_interval(self, interval):
        &#34;&#34;&#34;
        Set the analog scanning interval.

        :param interval: value of 0 - 255 - milliseconds
        &#34;&#34;&#34;

        if 0 &lt;= interval &lt;= 255:
            command = [PrivateConstants.SET_ANALOG_SCANNING_INTERVAL, interval]
            self._send_command(command)
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;Analog interval must be between 0 and 255&#39;)

    def set_pin_mode_analog_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a pwm (analog output) pin.

        :param pin_number:arduino pin number

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)

    def set_pin_mode_analog_input(self, pin_number, differential=0, callback=None):
        &#34;&#34;&#34;
        Set a pin as an analog input.

        :param pin_number: arduino pin number

        :param differential: difference in previous to current value before
                             report will be generated

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for analog input pins = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_ANALOG, differential,
                           callback)

    def set_pin_mode_digital_input(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input.

        :param pin_number: arduino pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins = 0

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT, callback=callback)

    def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pullup enabled.

        :param pin_number: arduino pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 11

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULLUP, callback)

    def set_pin_mode_digital_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a digital output pin.

        :param pin_number: arduino pin number
        &#34;&#34;&#34;

        self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)

    def set_pin_mode_i2c(self, i2c_port=0):
        &#34;&#34;&#34;
        Establish the standard Arduino i2c pins for i2c utilization.

        :param i2c_port: 0 = i2c1, 1 = i2c2

        NOTES: 1. THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
               2. Callbacks are set within the individual i2c read methods of this
              API.

              See i2c_read, or i2c_read_restart_transmission.

        &#34;&#34;&#34;
        # test for i2c port 2
        if i2c_port:
            # if not previously activated set it to activated
            # and the send a begin message for this port
            if not self.i2c_2_active:
                self.i2c_2_active = True
            else:
                return
        # port 1
        else:
            if not self.i2c_1_active:
                self.i2c_1_active = True
            else:
                return

        command = [PrivateConstants.I2C_BEGIN, i2c_port]
        self._send_command(command)

    def set_pin_mode_dht(self, pin, callback=None, dht_type=22):
        &#34;&#34;&#34;

        :param pin: connection pin

        :param callback: callback function

        :param dht_type: either 22 for DHT22 or 11 for DHT11

        Error Callback: [DHT REPORT Type, DHT_ERROR_NUMBER, PIN, DHT_TYPE, Time]

        Valid Data Callback: DHT REPORT Type, DHT_DATA=, PIN, DHT_TYPE, Humidity,
        Temperature,
        Time]

        &#34;&#34;&#34;

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;set_pin_mode_dht: A Callback must be specified&#39;)

        if self.dht_count &lt; PrivateConstants.MAX_DHTS - 1:
            self.dht_callbacks[pin] = callback
            self.dht_count += 1

            if dht_type != 22 and dht_type != 11:
                dht_type = 22

            command = [PrivateConstants.DHT_NEW, pin, dht_type]
            self._send_command(command)
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                f&#39;Maximum Number Of DHTs Exceeded - set_pin_mode_dht fails for pin {pin}&#39;)

    # noinspection PyRedundantParentheses
    def set_pin_mode_servo(self, pin_number, min_pulse=544, max_pulse=2400):
        &#34;&#34;&#34;

        Attach a pin to a servo motor

        :param pin_number: pin

        :param min_pulse: minimum pulse width

        :param max_pulse: maximum pulse width

        &#34;&#34;&#34;
        minv = (min_pulse).to_bytes(2, byteorder=&#34;big&#34;)
        maxv = (max_pulse).to_bytes(2, byteorder=&#34;big&#34;)

        command = [PrivateConstants.SERVO_ATTACH, pin_number,
                   minv[0], minv[1], maxv[0], maxv[1]]
        self._send_command(command)

    def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                           callback=None):
        &#34;&#34;&#34;

        :param trigger_pin:

        :param echo_pin:

        :param callback: callback

        callback data: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]

        &#34;&#34;&#34;

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;set_pin_mode_sonar: A Callback must be specified&#39;)

        if self.sonar_count &lt; PrivateConstants.MAX_SONARS - 1:
            self.sonar_callbacks[trigger_pin] = callback
            self.sonar_count += 1

            command = [PrivateConstants.SONAR_NEW, trigger_pin, echo_pin]
            self._send_command(command)
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                f&#39;Maximum Number Of Sonars Exceeded - set_pin_mode_sonar fails for pin {trigger_pin}&#39;)

    def set_pin_mode_spi(self, chip_select_list=None):
        &#34;&#34;&#34;
        Specify the list of chip select pins.

        Standard Arduino MISO, MOSI and CLK pins are used for the board in use.

        Chip Select is any digital output capable pin.

        :param chip_select_list: this is a list of pins to be used for chip select.
                           The pins will be configured as output, and set to high
                           ready to be used for chip select.
                           NOTE: You must specify the chips select pins here!


        command message: [command, number of cs pins, [cs pins...]]
        &#34;&#34;&#34;

        if type(chip_select_list) != list:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;chip_select_list must be in the form of a list&#39;)
        if not chip_select_list:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;Chip select pins were not specified&#39;)

        self.spi_enabled = True

        command = [PrivateConstants.SPI_INIT, len(chip_select_list)]

        for pin in chip_select_list:
            command.append(pin)
            self.cs_pins_enabled.append(pin)
        self._send_command(command)

    def servo_write(self, pin_number, angle):
        &#34;&#34;&#34;

        Set a servo attached to a pin to a given angle.

        :param pin_number: pin

        :param angle: angle (0-180)

        &#34;&#34;&#34;
        command = [PrivateConstants.SERVO_WRITE, pin_number, angle]
        self._send_command(command)

    def servo_detach(self, pin_number):
        &#34;&#34;&#34;
        Detach a servo for reuse

        :param pin_number: attached pin

        &#34;&#34;&#34;
        command = [PrivateConstants.SERVO_DETACH, pin_number]
        self._send_command(command)

    def _set_pin_mode(self, pin_number, pin_state, differential=0, callback=None):

        &#34;&#34;&#34;
        A private method to set the various pin modes.

        :param pin_number: arduino pin number

        :param pin_state: INPUT/OUTPUT/ANALOG/PWM/PULLUP
                         For SERVO use: set_pin_mode_servo
                         For DHT   use: set_pin_mode_dht

        :param differential: for analog inputs - threshold
                             value to be achieved for report to
                             be generated

        :param callback: A reference to a call back function to be
                         called when pin data value changes

        &#34;&#34;&#34;
        if callback:
            if pin_state == PrivateConstants.AT_INPUT:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_INPUT_PULLUP:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_ANALOG:
                self.analog_callbacks[pin_number] = callback
            else:
                print(&#39;{} {}&#39;.format(&#39;set_pin_mode: callback ignored for &#39;
                                     &#39;pin state:&#39;, pin_state))

        if pin_state == PrivateConstants.AT_INPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT, 1]

        elif pin_state == PrivateConstants.AT_INPUT_PULLUP:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT_PULLUP, 1]

        elif pin_state == PrivateConstants.AT_OUTPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_OUTPUT]

        elif pin_state == PrivateConstants.AT_ANALOG:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_ANALOG,
                       differential &gt;&gt; 8, differential &amp; 0xff, 1]
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;Unknown pin state&#39;)

        if command:
            self._send_command(command)

    def shutdown(self):
        &#34;&#34;&#34;
        This method attempts an orderly shutdown
        If any exceptions are thrown, they are ignored.
        &#34;&#34;&#34;
        self.shutdown_flag = True

        self._stop_threads()

        try:
            command = [PrivateConstants.STOP_ALL_REPORTS]
            self._send_command(command)
            time.sleep(.5)

            if self.ip_address:
                try:
                    self.sock.shutdown(socket.SHUT_RDWR)
                    self.sock.close()
                except Exception:
                    pass
            else:
                try:
                    self.serial_port.reset_input_buffer()
                    self.serial_port.close()

                except (RuntimeError, SerialException, OSError):
                    # ignore error on shutdown
                    pass
        except Exception:
            raise RuntimeError(&#39;Shutdown failed - could not send stop streaming message&#39;)

    def spi_cs_control(self, chip_select_pin, select):
        &#34;&#34;&#34;
        Control an SPI chip select line
        :param chip_select_pin: pin connected to CS

        :param select: 0=select, 1=deselect
        &#34;&#34;&#34;
        if not self.spi_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_cs_control: SPI interface is not enabled.&#39;)

        if chip_select_pin not in self.cs_pins_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_cs_control: chip select pin never enabled.&#39;)
        command = [PrivateConstants.SPI_CS_CONTROL, chip_select_pin, select]
        self._send_command(command)

    def spi_read_blocking(self, register_selection, number_of_bytes_to_read,
                          call_back=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified SPI port and
        call the callback function with the reported data.

        :param register_selection: Register to be selected for read.

        :param number_of_bytes_to_read: Number of bytes to read

        :param call_back: Required callback function to report spi data as a
                   result of read command


        callback returns a data list:
        [SPI_READ_REPORT, count of data bytes read, data bytes, time-stamp]

        SPI_READ_REPORT = 13

        &#34;&#34;&#34;

        if not self.spi_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_read_blocking: SPI interface is not enabled.&#39;)

        if not call_back:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;spi_read_blocking: A Callback must be specified&#39;)

        self.spi_callback = call_back

        command = [PrivateConstants.SPI_READ_BLOCKING, number_of_bytes_to_read,
                   register_selection]

        self._send_command(command)

    def spi_set_format(self, clock_divisor, bit_order, data_mode):
        &#34;&#34;&#34;
        Configure how the SPI serializes and de-serializes data on the wire.

        See Arduino SPI reference materials for details.

        :param clock_divisor:

        :param bit_order:   LSBFIRST = 0

                            MSBFIRST = 1 (default)

        :param data_mode:   SPI_MODE0 = 0x00 (default)

                            SPI_MODE1  = 0x04

                            SPI_MODE2 = 0x08

                            SPI_MODE3 = 0x0C

        &#34;&#34;&#34;

        if not self.spi_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_set_format: SPI interface is not enabled.&#39;)

        command = [PrivateConstants.SPI_SET_FORMAT, clock_divisor, bit_order,
                   data_mode]
        self._send_command(command)

    def spi_write_blocking(self, bytes_to_write):
        &#34;&#34;&#34;
        Write a list of bytes to the SPI device.

        :param bytes_to_write: A list of bytes to write. This must be in the form of a
        list.

        &#34;&#34;&#34;

        if not self.spi_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_write_blocking: SPI interface is not enabled.&#39;)

        if type(bytes_to_write) is not list:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;spi_write_blocking: bytes_to_write must be a list.&#39;)

        command = [PrivateConstants.SPI_WRITE_BLOCKING, len(bytes_to_write)]

        for data in bytes_to_write:
            command.append(data)

        self._send_command(command)

    def set_pin_mode_one_wire(self, pin):
        &#34;&#34;&#34;
        Initialize the one wire serial bus.
        :param pin: Data pin used with the OneWire device
        &#34;&#34;&#34;
        self.onewire_enabled = True
        command = [PrivateConstants.ONE_WIRE_INIT, pin]
        self._send_command(command)

    def onewire_reset(self):
        &#34;&#34;&#34;
        Reset the onewire device
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_reset: OneWire interface is not enabled.&#39;)
        command = [PrivateConstants.ONE_WIRE_RESET]
        self._send_command(command)

    def onewire_select(self, device_address):
        &#34;&#34;&#34;
        Select a device based on its address
        :param device_address: A bytearray of 8 bytes
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_select: OneWire interface is not enabled.&#39;)

        if type(device_address) is not bytearray:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_select: device address must be an array of 8 &#39;
                               &#39;bytes.&#39;)

        if len(device_address) != 8:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_select: device address must be an array of 8 &#39;
                               &#39;bytes.&#39;)
        command = [PrivateConstants.ONE_WIRE_SELECT]
        for data in device_address:
            command.append(data)
        self._send_command(command)

    def onewire_skip(self):
        &#34;&#34;&#34;
        Skip the device selection. This only works if you have a
        single device, but you can avoid searching and use this to
        immediately access your device.
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_skip: OneWire interface is not enabled.&#39;)

        command = [PrivateConstants.ONE_WIRE_SKIP]
        self._send_command(command)

    def onewire_write(self, data, power=0):
        &#34;&#34;&#34;
        Write a to the onewire device. If &#39;power&#39; is one then the wire is held high at
        the end for parasitically powered devices. You are responsible
        for eventually de-powering it by calling another read or write.

        :param data: byte to write.
        :param power: power control (see above)
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_write: OneWire interface is not enabled.&#39;)
        if 0 &lt; data &lt; 255:
            command = [PrivateConstants.ONE_WIRE_WRITE, data, power]
            self._send_command(command)
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_write: Data must be no larger than 255&#39;)

    def onewire_read(self, callback=None):
        &#34;&#34;&#34;
        Read a byte from the onewire device
        :param callback: required  function to report onewire data as a
                   result of read command


        callback returns a data list:
        [ONEWIRE_REPORT, ONEWIRE_READ=29, data byte, time-stamp]

        ONEWIRE_REPORT = 14
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_read: OneWire interface is not enabled.&#39;)

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_read A Callback must be specified&#39;)

        self.onewire_callback = callback

        command = [PrivateConstants.ONE_WIRE_READ]
        self._send_command(command)

    def onewire_reset_search(self):
        &#34;&#34;&#34;
        Begin a new search. The next use of search will begin at the first device
        &#34;&#34;&#34;

        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_reset_serach: OneWire interface is not enabled.&#39;)
        else:
            command = [PrivateConstants.ONE_WIRE_RESET_SEARCH]
            self._send_command(command)

    def onewire_search(self, callback=None):
        &#34;&#34;&#34;
        Search for the next device. The device address will returned in the callback.
        If a device is found, the 8 byte address is contained in the callback.
        If no more devices are found, the address returned contains all elements set
        to 0xff.

        :param callback: required  function to report a onewire device address

        callback returns a data list:
        [ONEWIRE_REPORT, ONEWIRE_SEARCH=31, 8 byte address, time-stamp]

        ONEWIRE_REPORT = 14
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_search: OneWire interface is not enabled.&#39;)

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_read A Callback must be specified&#39;)

        self.onewire_callback = callback

        command = [PrivateConstants.ONE_WIRE_SEARCH]
        self._send_command(command)

    def onewire_crc8(self, address_list, callback=None):
        &#34;&#34;&#34;
        Compute a CRC check on an array of data.
        :param address_list:

        :param callback: required  function to report a onewire device address

        callback returns a data list:
        [ONEWIRE_REPORT, ONEWIRE_CRC8=32, CRC, time-stamp]

        ONEWIRE_REPORT = 14

        &#34;&#34;&#34;

        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_crc8: OneWire interface is not enabled.&#39;)

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_crc8 A Callback must be specified&#39;)

        if type(address_list) is not list:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_crc8: address list must be a list.&#39;)

        self.onewire_callback = callback

        address_length = len(address_list)

        command = [PrivateConstants.ONE_WIRE_CRC8, address_length - 1]

        for data in address_list:
            command.append(data)

        self._send_command(command)

    &#39;&#39;&#39;
    report message handlers
    &#39;&#39;&#39;

    def _analog_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for analog messages.

        :param data: message data

        &#34;&#34;&#34;
        pin = data[0]
        value = (data[1] &lt;&lt; 8) + data[2]
        # set the current value in the pin structure
        time_stamp = time.time()
        # self.digital_pins[pin].event_time = time_stamp
        if self.analog_callbacks[pin]:
            message = [PrivateConstants.ANALOG_REPORT, pin, value, time_stamp]
            self.analog_callbacks[pin](message)

    def _dht_report(self, data):
        &#34;&#34;&#34;
        This is the dht report handler method.

        :param data:            data[0] = report error return
                                    No Errors = 0

                                    Checksum Error = 1

                                    Timeout Error = 2

                                    Invalid Value = 999

                                data[1] = pin number

                                data[2] = dht type 11 or 22

                                data[3] = humidity positivity flag

                                data[4] = temperature positivity value

                                data[5] = humidity integer

                                data[6] = humidity fractional value

                                data[7] = temperature integer

                                data[8] = temperature fractional value


        &#34;&#34;&#34;
        if data[0]:  # DHT_ERROR
            # error report
            # data[0] = report sub type, data[1] = pin, data[2] = error message
            if self.dht_callbacks[data[1]]:
                # Callback 0=DHT REPORT, DHT_ERROR, PIN, Time
                message = [PrivateConstants.DHT_REPORT, data[0], data[1], data[2],
                           time.time()]
                self.dht_callbacks[data[1]](message)
        else:
            # got valid data DHT_DATA
            f_humidity = float(data[5] + data[6] / 100)
            if data[3]:
                f_humidity *= -1.0
            f_temperature = float(data[7] + data[8] / 100)
            if data[4]:
                f_temperature *= -1.0
            message = [PrivateConstants.DHT_REPORT, data[0], data[1], data[2],
                       f_humidity, f_temperature, time.time()]

            self.dht_callbacks[data[1]](message)

    def _digital_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for Digital Messages.

        :param data: digital message

        &#34;&#34;&#34;
        pin = data[0]
        value = data[1]

        time_stamp = time.time()
        if self.digital_callbacks[pin]:
            message = [PrivateConstants.DIGITAL_REPORT, pin, value, time_stamp]
            self.digital_callbacks[pin](message)

    def _firmware_message(self, data):
        &#34;&#34;&#34;
        Telemetrix4Arduino firmware version message

        :param data: data[0] = major number, data[1] = minor number.

                               data[2] = patch number
        &#34;&#34;&#34;

        self.firmware_version = [data[0], data[1], data[2]]

    def _i2c_read_report(self, data):
        &#34;&#34;&#34;
        Execute callback for i2c reads.

        :param data: [I2C_READ_REPORT, i2c_port, number of bytes read, address, register, bytes read..., time-stamp]
        &#34;&#34;&#34;

        # we receive [# data bytes, address, register, data bytes]
        # number of bytes of data returned

        # data[0] = number of bytes
        # data[1] = i2c_port
        # data[2] = number of bytes returned
        # data[3] = address
        # data[4] = register
        # data[5] ... all the data bytes

        cb_list = [PrivateConstants.I2C_READ_REPORT, data[0], data[1]] + data[2:]
        cb_list.append(time.time())

        if cb_list[1]:
            self.i2c_callback2(cb_list)
        else:
            self.i2c_callback(cb_list)

    def _i2c_too_few(self, data):
        &#34;&#34;&#34;
        I2c reports too few bytes received

        :param data: data[0] = device address
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;i2c too few bytes received from i2c port {data[0]} i2c address {data[1]}&#39;)

    def _i2c_too_many(self, data):
        &#34;&#34;&#34;
        I2c reports too few bytes received

        :param data: data[0] = device address
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;i2c too many bytes received from i2c port {data[0]} i2c address {data[1]}&#39;)

    def _i_am_here(self, data):
        &#34;&#34;&#34;
        Reply to are_u_there message
        :param data: arduino id
        &#34;&#34;&#34;
        self.reported_arduino_id = data[0]

    def _one_wire_report(self, report):
        print(report)

    def _spi_report(self, report):

        cb_list = [PrivateConstants.SPI_REPORT, report[0]] + report[1:]

        cb_list.append(time.time())

        self.spi_callback(cb_list)

    def _onewire_report(self, report):
        cb_list = [PrivateConstants.ONE_WIRE_REPORT, report[0]] + report[1:]
        self.onewire_callback(cb_list)


    def _report_debug_data(self, data):
        &#34;&#34;&#34;
        Print debug data sent from Arduino
        :param data: data[0] is a byte followed by 2
                     bytes that comprise an integer
        :return:
        &#34;&#34;&#34;
        value = (data[1] &lt;&lt; 8) + data[2]
        print(f&#39;DEBUG ID: {data[0]} Value: {value}&#39;)

    def _report_loop_data(self, data):
        &#34;&#34;&#34;
        Print data that was looped back
        :param data: byte of loop back data
        :return:
        &#34;&#34;&#34;
        if self.loop_back_callback:
            self.loop_back_callback(data)

    def _send_command(self, command):
        &#34;&#34;&#34;
        This is a private utility method.


        :param command:  command data in the form of a list

        &#34;&#34;&#34;
        # the length of the list is added at the head
        command.insert(0, len(command))
        send_message = bytes(command)

        if self.serial_port:
            try:
                self.serial_port.write(send_message)
            except SerialException:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;write fail in _send_command&#39;)
        elif self.ip_address:
            self.sock.sendall(send_message)
        else:
            raise RuntimeError(&#39;No serial port or ip address set.&#39;)

    def _servo_unavailable(self, report):
        &#34;&#34;&#34;
        Message if no servos are available for use.
        :param report: pin number
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;Servo Attach For Pin {report[0]} Failed: No Available Servos&#39;)

    def _sonar_distance_report(self, report):
        &#34;&#34;&#34;

        :param report: data[0] = trigger pin, data[1] and data[2] = distance

        callback report format: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]
        &#34;&#34;&#34;

        # get callback from pin number
        cb = self.sonar_callbacks[report[0]]

        # build report data
        cb_list = [PrivateConstants.SONAR_DISTANCE, report[0],
                   ((report[1] &lt;&lt; 8) + report[2]), time.time()]

        cb(cb_list)

    def _run_threads(self):
        self.run_event.set()

    def _is_running(self):
        return self.run_event.is_set()

    def _stop_threads(self):
        self.run_event.clear()

    def _reporter(self):
        &#34;&#34;&#34;
        This is the reporter thread. It continuously pulls data from
        the deque. When a full message is detected, that message is
        processed.
        &#34;&#34;&#34;
        self.run_event.wait()

        while self._is_running() and not self.shutdown_flag:
            if len(self.the_deque):
                # response_data will be populated with the received data for the report
                response_data = []
                packet_length = self.the_deque.popleft()
                if packet_length:
                    # get all the data for the report and place it into response_data
                    for i in range(packet_length):
                        while not len(self.the_deque):
                            time.sleep(self.sleep_tune)
                        data = self.the_deque.popleft()
                        response_data.append(data)

                    # print(response_data)

                    # get the report type and look up its dispatch method
                    # here we pop the report type off of response_data
                    report_type = response_data.pop(0)
                    # print(report_type)

                    # retrieve the report handler from the dispatch table
                    dispatch_entry = self.report_dispatch.get(report_type)

                    # if there is additional data for the report,
                    # it will be contained in response_data
                    # noinspection PyArgumentList
                    dispatch_entry(response_data)
                    continue
                else:
                    if self.shutdown_on_exception:
                        self.shutdown()
                    raise RuntimeError(
                        &#39;A report with a packet length of zero was received.&#39;)
            else:
                time.sleep(self.sleep_tune)

    def _serial_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()

        # Don&#39;t start this thread if using a tcp/ip transport
        if self.ip_address:
            return

        while self._is_running() and not self.shutdown_flag:
            # we can get an OSError: [Errno9] Bad file descriptor when shutting down
            # just ignore it
            try:
                if self.serial_port.inWaiting():
                    c = self.serial_port.read()
                    self.the_deque.append(ord(c))
                    # print(ord(c))
                else:
                    time.sleep(self.sleep_tune)
                    # continue
            except OSError:
                pass

    def _tcp_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()

        # Start this thread only if ip_address is set

        if self.ip_address:

            while self._is_running() and not self.shutdown_flag:
                try:
                    payload = self.sock.recv(1)
                    self.the_deque.append(ord(payload))
                except Exception:
                    pass
        else:
            return</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="telemetrix.telemetrix.Telemetrix"><code class="flex name class">
<span>class <span class="ident">Telemetrix</span></span>
<span>(</span><span>com_port=None, arduino_instance_id=1, arduino_wait=4, sleep_tune=1e-06, shutdown_on_exception=True, ip_address=None, ip_port=31335)</span>
</code></dt>
<dd>
<div class="desc"><p>This class exposes and implements the telemetrix API.
It uses threading to accommodate concurrency.
It includes the public API methods as well as
a set of private methods.</p>
<p>:param com_port: e.g. COM3 or /dev/ttyACM0.
Only use if you wish to bypass auto com port
detection.</p>
<p>:param arduino_instance_id: Match with the value installed on the
arduino-telemetrix sketch.</p>
<p>:param arduino_wait: Amount of time to wait for an Arduino to
fully reset itself.</p>
<p>:param sleep_tune: A tuning parameter (typically not changed by user)</p>
<p>:param shutdown_on_exception: call shutdown before raising
a RunTimeError exception, or
receiving a KeyboardInterrupt exception</p>
<p>:param ip_address: ip address of tcp/ip connected device.</p>
<p>:param ip_port: ip port of tcp/ip connected device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Telemetrix(threading.Thread):
    &#34;&#34;&#34;
    This class exposes and implements the telemetrix API.
    It uses threading to accommodate concurrency.
    It includes the public API methods as well as
    a set of private methods.

    &#34;&#34;&#34;

    # noinspection PyPep8,PyPep8,PyPep8
    def __init__(self, com_port=None, arduino_instance_id=1,
                 arduino_wait=4, sleep_tune=0.000001,
                 shutdown_on_exception=True,
                 ip_address=None, ip_port=31335):

        &#34;&#34;&#34;

        :param com_port: e.g. COM3 or /dev/ttyACM0.
                         Only use if you wish to bypass auto com port
                         detection.

        :param arduino_instance_id: Match with the value installed on the
                                    arduino-telemetrix sketch.

        :param arduino_wait: Amount of time to wait for an Arduino to
                             fully reset itself.

        :param sleep_tune: A tuning parameter (typically not changed by user)

        :param shutdown_on_exception: call shutdown before raising
                                      a RunTimeError exception, or
                                      receiving a KeyboardInterrupt exception

        :param ip_address: ip address of tcp/ip connected device.

        :param ip_port: ip port of tcp/ip connected device
        &#34;&#34;&#34;

        # initialize threading parent
        threading.Thread.__init__(self)

        # create the threads and set them as daemons so
        # that they stop when the program is closed

        # create a thread to interpret received serial data
        self.the_reporter_thread = threading.Thread(target=self._reporter)
        self.the_reporter_thread.daemon = True

        self.ip_address = ip_address
        self.ip_port = ip_port

        if not self.ip_address:
            self.the_data_receive_thread = threading.Thread(target=self._serial_receiver)
        else:
            self.the_data_receive_thread = threading.Thread(target=self._tcp_receiver)

        self.the_data_receive_thread.daemon = True

        # flag to allow the reporter and receive threads to run.
        self.run_event = threading.Event()

        # check to make sure that Python interpreter is version 3.7 or greater
        python_version = sys.version_info
        if python_version[0] &gt;= 3:
            if python_version[1] &gt;= 7:
                pass
            else:
                raise RuntimeError(&#34;ERROR: Python 3.7 or greater is &#34;
                                   &#34;required for use of this program.&#34;)

        # save input parameters as instance variables
        self.com_port = com_port
        self.arduino_instance_id = arduino_instance_id
        self.arduino_wait = arduino_wait
        self.sleep_tune = sleep_tune
        self.shutdown_on_exception = shutdown_on_exception

        # create a deque to receive and process data from the arduino
        self.the_deque = deque()

        # The report_dispatch dictionary is used to process
        # incoming report messages by looking up the report message
        # and executing its associated processing method.

        self.report_dispatch = {}

        # To add a command to the command dispatch table, append here.
        self.report_dispatch.update(
            {PrivateConstants.LOOP_COMMAND: self._report_loop_data})
        self.report_dispatch.update(
            {PrivateConstants.DEBUG_PRINT: self._report_debug_data})
        self.report_dispatch.update(
            {PrivateConstants.DIGITAL_REPORT: self._digital_message})
        self.report_dispatch.update(
            {PrivateConstants.ANALOG_REPORT: self._analog_message})
        self.report_dispatch.update(
            {PrivateConstants.FIRMWARE_REPORT: self._firmware_message})
        self.report_dispatch.update({PrivateConstants.I_AM_HERE_REPORT: self._i_am_here})
        self.report_dispatch.update(
            {PrivateConstants.SERVO_UNAVAILABLE: self._servo_unavailable})
        self.report_dispatch.update(
            {PrivateConstants.I2C_READ_REPORT: self._i2c_read_report})
        self.report_dispatch.update(
            {PrivateConstants.I2C_TOO_FEW_BYTES_RCVD: self._i2c_too_few})
        self.report_dispatch.update(
            {PrivateConstants.I2C_TOO_MANY_BYTES_RCVD: self._i2c_too_many})
        self.report_dispatch.update(
            {PrivateConstants.SONAR_DISTANCE: self._sonar_distance_report})
        self.report_dispatch.update({PrivateConstants.DHT_REPORT: self._dht_report})
        self.report_dispatch.update(
            {PrivateConstants.SPI_REPORT: self._spi_report})
        self.report_dispatch.update(
            {PrivateConstants.ONE_WIRE_REPORT: self._onewire_report})

        # dictionaries to store the callbacks for each pin
        self.analog_callbacks = {}

        self.digital_callbacks = {}

        self.i2c_callback = None
        self.i2c_callback2 = None

        self.i2c_1_active = False
        self.i2c_2_active = False

        self.spi_callback = None

        self.onewire_callback = None

        self.cs_pins_enabled = []

        # the trigger pin will be the key to retrieve
        # the callback for a specific HC-SR04
        self.sonar_callbacks = {}

        self.sonar_count = 0

        self.dht_callbacks = {}

        self.dht_count = 0

        # serial port in use
        self.serial_port = None

        # socket for tcp/ip communications
        self.sock = None

        # flag to indicate we are in shutdown mode
        self.shutdown_flag = False

        # debug loopback callback method
        self.loop_back_callback = None

        # flag to indicate the start of a new report
        # self.new_report_start = True

        # firmware version to be stored here
        self.firmware_version = []

        # reported arduino instance id
        self.reported_arduino_id = []

        # flag to indicate if i2c was previously enabled
        self.i2c_enabled = False

        # flag to indicate if spi is initialized
        self.spi_enabled = False

        # flag to indicate if onewire is initialized
        self.onewire_enabled = False

        self.the_reporter_thread.start()
        self.the_data_receive_thread.start()

        print(f&#34;Telemetrix:  Version {PrivateConstants.TELEMETRIX_VERSION}\n\n&#34;
              f&#34;Copyright (c) 2020 Alan Yorinks All Rights Reserved.\n&#34;)

        # using the serial link
        if not self.ip_address:
            if not self.com_port:
                # user did not specify a com_port
                try:
                    self._find_arduino()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        self.shutdown()
            else:
                # com_port specified - set com_port and baud rate
                try:
                    self._manual_open()
                except KeyboardInterrupt:
                    if self.shutdown_on_exception:
                        self.shutdown()

            if self.serial_port:
                print(
                    f&#34;Arduino compatible device found and connected to {self.serial_port.port}&#34;)

                self.serial_port.reset_input_buffer()
                self.serial_port.reset_output_buffer()

            # no com_port found - raise a runtime exception
            else:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;No Arduino Found or User Aborted Program&#39;)
        else:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.ip_address, self.ip_port))
            print(f&#39;Successfully connected to: {self.ip_address}:{self.ip_port}&#39;)

        # allow the threads to run
        self._run_threads()
        print(f&#39;Waiting for Arduino to reset&#39;)
        print(f&#39;Reset Complete&#39;)

        print(&#39;Retrieving Arduino ID...&#39;)
        self._get_arduino_id()
        if self.reported_arduino_id != self.arduino_instance_id:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;Incorrect Arduino ID: {self.reported_arduino_id}&#39;)
        print(&#39;Valid Arduino ID Found.&#39;)
        # get telemetrix firmware version and print it
        print(&#39;\nRetrieving Telemetrix4Arduino firmware ID...&#39;)
        self._get_firmware_version()
        if not self.firmware_version:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;Telemetrix4Arduino firmware version&#39;)

        else:
            print(f&#39;Telemetrix4Arduino firmware version: {self.firmware_version[0]}.&#39;
                  f&#39;{self.firmware_version[1]}.{self.firmware_version[2]}&#39;)
        command = [PrivateConstants.ENABLE_ALL_REPORTS]
        self._send_command(command)

        # Have the server reset its data structures
        command = [PrivateConstants.RESET]
        self._send_command(command)

    def _find_arduino(self):
        &#34;&#34;&#34;
        This method will search all potential serial ports for an Arduino
        containing a sketch that has a matching arduino_instance_id as
        specified in the input parameters of this class.

        This is used explicitly with the Telemetrix4Arduino sketch.
        &#34;&#34;&#34;

        # a list of serial ports to be checked
        serial_ports = []

        print(&#39;Opening all potential serial ports...&#39;)
        the_ports_list = list_ports.comports()
        for port in the_ports_list:
            if port.pid is None:
                continue
            try:
                self.serial_port = serial.Serial(port.device, 115200,
                                                 timeout=1, writeTimeout=0)
            except SerialException:
                continue
            # create a list of serial ports that we opened
            serial_ports.append(self.serial_port)

            # display to the user
            print(&#39;\t&#39; + port.device)

            # clear out any possible data in the input buffer
        # wait for arduino to reset
        print(
            f&#39;\nWaiting {self.arduino_wait} seconds(arduino_wait) for Arduino devices to &#39;
            &#39;reset...&#39;)
        # temporary for testing
        time.sleep(self.arduino_wait)

        # check for correct arduino device
        self.serial_port.reset_input_buffer()
        self.serial_port.reset_output_buffer()

    def _manual_open(self):
        &#34;&#34;&#34;
        Com port was specified by the user - try to open up that port

        &#34;&#34;&#34;
        # if port is not found, a serial exception will be thrown
        try:
            print(f&#39;Opening {self.com_port}...&#39;)
            self.serial_port = serial.Serial(self.com_port, 115200,
                                             timeout=1, writeTimeout=0)

            print(
                f&#39;\nWaiting {self.arduino_wait} seconds(arduino_wait) for Arduino devices to &#39;
                &#39;reset...&#39;)
            self._run_threads()
            time.sleep(self.arduino_wait)

            self._get_arduino_id()

            if self.reported_arduino_id != self.arduino_instance_id:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(f&#39;Incorrect Arduino ID: {self.reported_arduino_id}&#39;)
            print(&#39;Valid Arduino ID Found.&#39;)
            # get arduino firmware version and print it
            print(&#39;\nRetrieving Telemetrix4Arduino firmware ID...&#39;)
            self._get_firmware_version()

            if not self.firmware_version:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    f&#39;Telemetrix4Arduino Sketch Firmware Version Not Found&#39;)

            else:
                print(f&#39;Telemetrix4Arduino firmware version: {self.firmware_version[0]}.&#39;
                      f&#39;{self.firmware_version[1]}&#39;)
        except KeyboardInterrupt:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;User Hit Control-C&#39;)

    def analog_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: arduino pin number

        :param value: pin value (maximum 16 bits)

        &#34;&#34;&#34;
        value_msb = value &gt;&gt; 8
        value_lsb = value &amp; 0xff
        command = [PrivateConstants.ANALOG_WRITE, pin, value_msb, value_lsb]
        self._send_command(command)

    def digital_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: arduino pin number

        :param value: pin value (1 or 0)

        &#34;&#34;&#34;

        command = [PrivateConstants.DIGITAL_WRITE, pin, value]
        self._send_command(command)

    def disable_all_reporting(self):
        &#34;&#34;&#34;
        Disable reporting for all digital and analog input pins
        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DISABLE_ALL, 0]
        self._send_command(command)

    def disable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Disables analog reporting for a single analog pin.

        :param pin: Analog pin number. For example for A0, the number is 0.

        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_ANALOG_DISABLE, pin]
        self._send_command(command)

    def disable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Disables digital reporting for a single digital input.

        :param pin: Pin number.

        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DIGITAL_DISABLE, pin]
        self._send_command(command)

    def enable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Enables analog reporting for the specified pin.

        :param pin: Analog pin number. For example for A0, the number is 0.


        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_ANALOG_ENABLE, pin]
        self._send_command(command)

    def enable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Enable reporting on the specified digital pin.

        :param pin: Pin number.
        &#34;&#34;&#34;

        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DIGITAL_ENABLE, pin]
        self._send_command(command)

    def _get_arduino_id(self):
        &#34;&#34;&#34;
        Retrieve arduino-telemetrix arduino id

        &#34;&#34;&#34;
        command = [PrivateConstants.ARE_U_THERE]
        self._send_command(command)
        # provide time for the reply
        time.sleep(.5)

    def _get_firmware_version(self):
        &#34;&#34;&#34;
        This method retrieves the
        arduino-telemetrix firmware version

        &#34;&#34;&#34;
        command = [PrivateConstants.GET_FIRMWARE_VERSION]
        self._send_command(command)
        # provide time for the reply
        time.sleep(.5)

    def i2c_read(self, address, register, number_of_bytes,
                 callback=None, i2c_port=0):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Required callback function to report i2c data as a
                   result of read command

       :param i2c_port: 0 = default, 1 = secondary


        callback returns a data list:
        [I2C_READ_REPORT, address, register, count of data bytes, data bytes, time-stamp]

        &#34;&#34;&#34;

        self._i2c_read_request(address, register, number_of_bytes,
                               callback=callback, i2c_port=i2c_port)

    def i2c_read_restart_transmission(self, address, register,
                                      number_of_bytes,
                                      callback=None, i2c_port=0):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device. This restarts the transmission after the read. It is
        required for some i2c devices such as the MMA8452Q accelerometer.


        :param address: i2c device address

        :param register: i2c register (or None if no register
                                                    selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Required callback function to report i2c data as a
                   result of read command

       :param i2c_port: 0 = default 1 = secondary


        callback returns a data list:

        [I2C_READ_REPORT, address, register, count of data bytes, data bytes, time-stamp]

        &#34;&#34;&#34;

        self._i2c_read_request(address, register, number_of_bytes,
                               stop_transmission=False,
                               callback=callback, i2c_port=i2c_port)

    def _i2c_read_request(self, address, register, number_of_bytes,
                          stop_transmission=True, callback=None, i2c_port=0):
        &#34;&#34;&#34;
        This method requests the read of an i2c device. Results are retrieved
        via callback.

        :param address: i2c device address

        :param register: register number (or None if no register selection is needed)

        :param number_of_bytes: number of bytes expected to be returned

        :param stop_transmission: stop transmission after read

        :param callback: Required callback function to report i2c data as a
                   result of read command.

        &#34;&#34;&#34;
        if not i2c_port:
            if not self.i2c_1_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Read: set_pin_mode i2c never called for i2c port 1.&#39;)

        if i2c_port:
            if not self.i2c_2_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Read: set_pin_mode i2c never called for i2c port 2.&#39;)

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;I2C Read: A callback function must be specified.&#39;)

        if not i2c_port:
            self.i2c_callback = callback
        else:
            self.i2c_callback2 = callback

        if not register:
            register = 0

        # message contains:
        # 1. address
        # 2. register
        # 3. number of bytes
        # 4. restart_transmission - True or False
        # 5. i2c port

        command = [PrivateConstants.I2C_READ, address, register, number_of_bytes,
                   stop_transmission, i2c_port]
        self._send_command(command)

    def i2c_write(self, address, args, i2c_port=0):
        &#34;&#34;&#34;
        Write data to an i2c device.

        :param address: i2c device address

        :param i2c_port: 0= port 1, 1 = port 2

        :param args: A variable number of bytes to be sent to the device
                     passed in as a list

        &#34;&#34;&#34;
        if not i2c_port:
            if not self.i2c_1_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode i2c never called for i2c port 1.&#39;)

        if i2c_port:
            if not self.i2c_2_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode i2c never called for i2c port 2.&#39;)

        command = [PrivateConstants.I2C_WRITE, len(args), address, i2c_port]

        for item in args:
            command.append(item)

        self._send_command(command)

    def loop_back(self, start_character, callback=None):
        &#34;&#34;&#34;
        This is a debugging method to send a character to the
        Arduino device, and have the device loop it back.

        :param start_character: The character to loop back. It should be
                                an integer.

        :param callback: Looped back character will appear in the callback method

        &#34;&#34;&#34;
        command = [PrivateConstants.LOOP_COMMAND, ord(start_character)]
        self.loop_back_callback = callback
        self._send_command(command)

    def set_analog_scan_interval(self, interval):
        &#34;&#34;&#34;
        Set the analog scanning interval.

        :param interval: value of 0 - 255 - milliseconds
        &#34;&#34;&#34;

        if 0 &lt;= interval &lt;= 255:
            command = [PrivateConstants.SET_ANALOG_SCANNING_INTERVAL, interval]
            self._send_command(command)
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;Analog interval must be between 0 and 255&#39;)

    def set_pin_mode_analog_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a pwm (analog output) pin.

        :param pin_number:arduino pin number

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)

    def set_pin_mode_analog_input(self, pin_number, differential=0, callback=None):
        &#34;&#34;&#34;
        Set a pin as an analog input.

        :param pin_number: arduino pin number

        :param differential: difference in previous to current value before
                             report will be generated

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for analog input pins = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_ANALOG, differential,
                           callback)

    def set_pin_mode_digital_input(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input.

        :param pin_number: arduino pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins = 0

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT, callback=callback)

    def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pullup enabled.

        :param pin_number: arduino pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 11

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULLUP, callback)

    def set_pin_mode_digital_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a digital output pin.

        :param pin_number: arduino pin number
        &#34;&#34;&#34;

        self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)

    def set_pin_mode_i2c(self, i2c_port=0):
        &#34;&#34;&#34;
        Establish the standard Arduino i2c pins for i2c utilization.

        :param i2c_port: 0 = i2c1, 1 = i2c2

        NOTES: 1. THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
               2. Callbacks are set within the individual i2c read methods of this
              API.

              See i2c_read, or i2c_read_restart_transmission.

        &#34;&#34;&#34;
        # test for i2c port 2
        if i2c_port:
            # if not previously activated set it to activated
            # and the send a begin message for this port
            if not self.i2c_2_active:
                self.i2c_2_active = True
            else:
                return
        # port 1
        else:
            if not self.i2c_1_active:
                self.i2c_1_active = True
            else:
                return

        command = [PrivateConstants.I2C_BEGIN, i2c_port]
        self._send_command(command)

    def set_pin_mode_dht(self, pin, callback=None, dht_type=22):
        &#34;&#34;&#34;

        :param pin: connection pin

        :param callback: callback function

        :param dht_type: either 22 for DHT22 or 11 for DHT11

        Error Callback: [DHT REPORT Type, DHT_ERROR_NUMBER, PIN, DHT_TYPE, Time]

        Valid Data Callback: DHT REPORT Type, DHT_DATA=, PIN, DHT_TYPE, Humidity,
        Temperature,
        Time]

        &#34;&#34;&#34;

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;set_pin_mode_dht: A Callback must be specified&#39;)

        if self.dht_count &lt; PrivateConstants.MAX_DHTS - 1:
            self.dht_callbacks[pin] = callback
            self.dht_count += 1

            if dht_type != 22 and dht_type != 11:
                dht_type = 22

            command = [PrivateConstants.DHT_NEW, pin, dht_type]
            self._send_command(command)
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                f&#39;Maximum Number Of DHTs Exceeded - set_pin_mode_dht fails for pin {pin}&#39;)

    # noinspection PyRedundantParentheses
    def set_pin_mode_servo(self, pin_number, min_pulse=544, max_pulse=2400):
        &#34;&#34;&#34;

        Attach a pin to a servo motor

        :param pin_number: pin

        :param min_pulse: minimum pulse width

        :param max_pulse: maximum pulse width

        &#34;&#34;&#34;
        minv = (min_pulse).to_bytes(2, byteorder=&#34;big&#34;)
        maxv = (max_pulse).to_bytes(2, byteorder=&#34;big&#34;)

        command = [PrivateConstants.SERVO_ATTACH, pin_number,
                   minv[0], minv[1], maxv[0], maxv[1]]
        self._send_command(command)

    def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                           callback=None):
        &#34;&#34;&#34;

        :param trigger_pin:

        :param echo_pin:

        :param callback: callback

        callback data: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]

        &#34;&#34;&#34;

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;set_pin_mode_sonar: A Callback must be specified&#39;)

        if self.sonar_count &lt; PrivateConstants.MAX_SONARS - 1:
            self.sonar_callbacks[trigger_pin] = callback
            self.sonar_count += 1

            command = [PrivateConstants.SONAR_NEW, trigger_pin, echo_pin]
            self._send_command(command)
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                f&#39;Maximum Number Of Sonars Exceeded - set_pin_mode_sonar fails for pin {trigger_pin}&#39;)

    def set_pin_mode_spi(self, chip_select_list=None):
        &#34;&#34;&#34;
        Specify the list of chip select pins.

        Standard Arduino MISO, MOSI and CLK pins are used for the board in use.

        Chip Select is any digital output capable pin.

        :param chip_select_list: this is a list of pins to be used for chip select.
                           The pins will be configured as output, and set to high
                           ready to be used for chip select.
                           NOTE: You must specify the chips select pins here!


        command message: [command, number of cs pins, [cs pins...]]
        &#34;&#34;&#34;

        if type(chip_select_list) != list:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;chip_select_list must be in the form of a list&#39;)
        if not chip_select_list:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;Chip select pins were not specified&#39;)

        self.spi_enabled = True

        command = [PrivateConstants.SPI_INIT, len(chip_select_list)]

        for pin in chip_select_list:
            command.append(pin)
            self.cs_pins_enabled.append(pin)
        self._send_command(command)

    def servo_write(self, pin_number, angle):
        &#34;&#34;&#34;

        Set a servo attached to a pin to a given angle.

        :param pin_number: pin

        :param angle: angle (0-180)

        &#34;&#34;&#34;
        command = [PrivateConstants.SERVO_WRITE, pin_number, angle]
        self._send_command(command)

    def servo_detach(self, pin_number):
        &#34;&#34;&#34;
        Detach a servo for reuse

        :param pin_number: attached pin

        &#34;&#34;&#34;
        command = [PrivateConstants.SERVO_DETACH, pin_number]
        self._send_command(command)

    def _set_pin_mode(self, pin_number, pin_state, differential=0, callback=None):

        &#34;&#34;&#34;
        A private method to set the various pin modes.

        :param pin_number: arduino pin number

        :param pin_state: INPUT/OUTPUT/ANALOG/PWM/PULLUP
                         For SERVO use: set_pin_mode_servo
                         For DHT   use: set_pin_mode_dht

        :param differential: for analog inputs - threshold
                             value to be achieved for report to
                             be generated

        :param callback: A reference to a call back function to be
                         called when pin data value changes

        &#34;&#34;&#34;
        if callback:
            if pin_state == PrivateConstants.AT_INPUT:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_INPUT_PULLUP:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_ANALOG:
                self.analog_callbacks[pin_number] = callback
            else:
                print(&#39;{} {}&#39;.format(&#39;set_pin_mode: callback ignored for &#39;
                                     &#39;pin state:&#39;, pin_state))

        if pin_state == PrivateConstants.AT_INPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT, 1]

        elif pin_state == PrivateConstants.AT_INPUT_PULLUP:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT_PULLUP, 1]

        elif pin_state == PrivateConstants.AT_OUTPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_OUTPUT]

        elif pin_state == PrivateConstants.AT_ANALOG:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_ANALOG,
                       differential &gt;&gt; 8, differential &amp; 0xff, 1]
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;Unknown pin state&#39;)

        if command:
            self._send_command(command)

    def shutdown(self):
        &#34;&#34;&#34;
        This method attempts an orderly shutdown
        If any exceptions are thrown, they are ignored.
        &#34;&#34;&#34;
        self.shutdown_flag = True

        self._stop_threads()

        try:
            command = [PrivateConstants.STOP_ALL_REPORTS]
            self._send_command(command)
            time.sleep(.5)

            if self.ip_address:
                try:
                    self.sock.shutdown(socket.SHUT_RDWR)
                    self.sock.close()
                except Exception:
                    pass
            else:
                try:
                    self.serial_port.reset_input_buffer()
                    self.serial_port.close()

                except (RuntimeError, SerialException, OSError):
                    # ignore error on shutdown
                    pass
        except Exception:
            raise RuntimeError(&#39;Shutdown failed - could not send stop streaming message&#39;)

    def spi_cs_control(self, chip_select_pin, select):
        &#34;&#34;&#34;
        Control an SPI chip select line
        :param chip_select_pin: pin connected to CS

        :param select: 0=select, 1=deselect
        &#34;&#34;&#34;
        if not self.spi_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_cs_control: SPI interface is not enabled.&#39;)

        if chip_select_pin not in self.cs_pins_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_cs_control: chip select pin never enabled.&#39;)
        command = [PrivateConstants.SPI_CS_CONTROL, chip_select_pin, select]
        self._send_command(command)

    def spi_read_blocking(self, register_selection, number_of_bytes_to_read,
                          call_back=None):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified SPI port and
        call the callback function with the reported data.

        :param register_selection: Register to be selected for read.

        :param number_of_bytes_to_read: Number of bytes to read

        :param call_back: Required callback function to report spi data as a
                   result of read command


        callback returns a data list:
        [SPI_READ_REPORT, count of data bytes read, data bytes, time-stamp]

        SPI_READ_REPORT = 13

        &#34;&#34;&#34;

        if not self.spi_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_read_blocking: SPI interface is not enabled.&#39;)

        if not call_back:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;spi_read_blocking: A Callback must be specified&#39;)

        self.spi_callback = call_back

        command = [PrivateConstants.SPI_READ_BLOCKING, number_of_bytes_to_read,
                   register_selection]

        self._send_command(command)

    def spi_set_format(self, clock_divisor, bit_order, data_mode):
        &#34;&#34;&#34;
        Configure how the SPI serializes and de-serializes data on the wire.

        See Arduino SPI reference materials for details.

        :param clock_divisor:

        :param bit_order:   LSBFIRST = 0

                            MSBFIRST = 1 (default)

        :param data_mode:   SPI_MODE0 = 0x00 (default)

                            SPI_MODE1  = 0x04

                            SPI_MODE2 = 0x08

                            SPI_MODE3 = 0x0C

        &#34;&#34;&#34;

        if not self.spi_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_set_format: SPI interface is not enabled.&#39;)

        command = [PrivateConstants.SPI_SET_FORMAT, clock_divisor, bit_order,
                   data_mode]
        self._send_command(command)

    def spi_write_blocking(self, bytes_to_write):
        &#34;&#34;&#34;
        Write a list of bytes to the SPI device.

        :param bytes_to_write: A list of bytes to write. This must be in the form of a
        list.

        &#34;&#34;&#34;

        if not self.spi_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;spi_write_blocking: SPI interface is not enabled.&#39;)

        if type(bytes_to_write) is not list:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;spi_write_blocking: bytes_to_write must be a list.&#39;)

        command = [PrivateConstants.SPI_WRITE_BLOCKING, len(bytes_to_write)]

        for data in bytes_to_write:
            command.append(data)

        self._send_command(command)

    def set_pin_mode_one_wire(self, pin):
        &#34;&#34;&#34;
        Initialize the one wire serial bus.
        :param pin: Data pin used with the OneWire device
        &#34;&#34;&#34;
        self.onewire_enabled = True
        command = [PrivateConstants.ONE_WIRE_INIT, pin]
        self._send_command(command)

    def onewire_reset(self):
        &#34;&#34;&#34;
        Reset the onewire device
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_reset: OneWire interface is not enabled.&#39;)
        command = [PrivateConstants.ONE_WIRE_RESET]
        self._send_command(command)

    def onewire_select(self, device_address):
        &#34;&#34;&#34;
        Select a device based on its address
        :param device_address: A bytearray of 8 bytes
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_select: OneWire interface is not enabled.&#39;)

        if type(device_address) is not bytearray:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_select: device address must be an array of 8 &#39;
                               &#39;bytes.&#39;)

        if len(device_address) != 8:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_select: device address must be an array of 8 &#39;
                               &#39;bytes.&#39;)
        command = [PrivateConstants.ONE_WIRE_SELECT]
        for data in device_address:
            command.append(data)
        self._send_command(command)

    def onewire_skip(self):
        &#34;&#34;&#34;
        Skip the device selection. This only works if you have a
        single device, but you can avoid searching and use this to
        immediately access your device.
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_skip: OneWire interface is not enabled.&#39;)

        command = [PrivateConstants.ONE_WIRE_SKIP]
        self._send_command(command)

    def onewire_write(self, data, power=0):
        &#34;&#34;&#34;
        Write a to the onewire device. If &#39;power&#39; is one then the wire is held high at
        the end for parasitically powered devices. You are responsible
        for eventually de-powering it by calling another read or write.

        :param data: byte to write.
        :param power: power control (see above)
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_write: OneWire interface is not enabled.&#39;)
        if 0 &lt; data &lt; 255:
            command = [PrivateConstants.ONE_WIRE_WRITE, data, power]
            self._send_command(command)
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_write: Data must be no larger than 255&#39;)

    def onewire_read(self, callback=None):
        &#34;&#34;&#34;
        Read a byte from the onewire device
        :param callback: required  function to report onewire data as a
                   result of read command


        callback returns a data list:
        [ONEWIRE_REPORT, ONEWIRE_READ=29, data byte, time-stamp]

        ONEWIRE_REPORT = 14
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_read: OneWire interface is not enabled.&#39;)

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_read A Callback must be specified&#39;)

        self.onewire_callback = callback

        command = [PrivateConstants.ONE_WIRE_READ]
        self._send_command(command)

    def onewire_reset_search(self):
        &#34;&#34;&#34;
        Begin a new search. The next use of search will begin at the first device
        &#34;&#34;&#34;

        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_reset_serach: OneWire interface is not enabled.&#39;)
        else:
            command = [PrivateConstants.ONE_WIRE_RESET_SEARCH]
            self._send_command(command)

    def onewire_search(self, callback=None):
        &#34;&#34;&#34;
        Search for the next device. The device address will returned in the callback.
        If a device is found, the 8 byte address is contained in the callback.
        If no more devices are found, the address returned contains all elements set
        to 0xff.

        :param callback: required  function to report a onewire device address

        callback returns a data list:
        [ONEWIRE_REPORT, ONEWIRE_SEARCH=31, 8 byte address, time-stamp]

        ONEWIRE_REPORT = 14
        &#34;&#34;&#34;
        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_search: OneWire interface is not enabled.&#39;)

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_read A Callback must be specified&#39;)

        self.onewire_callback = callback

        command = [PrivateConstants.ONE_WIRE_SEARCH]
        self._send_command(command)

    def onewire_crc8(self, address_list, callback=None):
        &#34;&#34;&#34;
        Compute a CRC check on an array of data.
        :param address_list:

        :param callback: required  function to report a onewire device address

        callback returns a data list:
        [ONEWIRE_REPORT, ONEWIRE_CRC8=32, CRC, time-stamp]

        ONEWIRE_REPORT = 14

        &#34;&#34;&#34;

        if not self.onewire_enabled:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;onewire_crc8: OneWire interface is not enabled.&#39;)

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_crc8 A Callback must be specified&#39;)

        if type(address_list) is not list:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;onewire_crc8: address list must be a list.&#39;)

        self.onewire_callback = callback

        address_length = len(address_list)

        command = [PrivateConstants.ONE_WIRE_CRC8, address_length - 1]

        for data in address_list:
            command.append(data)

        self._send_command(command)

    &#39;&#39;&#39;
    report message handlers
    &#39;&#39;&#39;

    def _analog_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for analog messages.

        :param data: message data

        &#34;&#34;&#34;
        pin = data[0]
        value = (data[1] &lt;&lt; 8) + data[2]
        # set the current value in the pin structure
        time_stamp = time.time()
        # self.digital_pins[pin].event_time = time_stamp
        if self.analog_callbacks[pin]:
            message = [PrivateConstants.ANALOG_REPORT, pin, value, time_stamp]
            self.analog_callbacks[pin](message)

    def _dht_report(self, data):
        &#34;&#34;&#34;
        This is the dht report handler method.

        :param data:            data[0] = report error return
                                    No Errors = 0

                                    Checksum Error = 1

                                    Timeout Error = 2

                                    Invalid Value = 999

                                data[1] = pin number

                                data[2] = dht type 11 or 22

                                data[3] = humidity positivity flag

                                data[4] = temperature positivity value

                                data[5] = humidity integer

                                data[6] = humidity fractional value

                                data[7] = temperature integer

                                data[8] = temperature fractional value


        &#34;&#34;&#34;
        if data[0]:  # DHT_ERROR
            # error report
            # data[0] = report sub type, data[1] = pin, data[2] = error message
            if self.dht_callbacks[data[1]]:
                # Callback 0=DHT REPORT, DHT_ERROR, PIN, Time
                message = [PrivateConstants.DHT_REPORT, data[0], data[1], data[2],
                           time.time()]
                self.dht_callbacks[data[1]](message)
        else:
            # got valid data DHT_DATA
            f_humidity = float(data[5] + data[6] / 100)
            if data[3]:
                f_humidity *= -1.0
            f_temperature = float(data[7] + data[8] / 100)
            if data[4]:
                f_temperature *= -1.0
            message = [PrivateConstants.DHT_REPORT, data[0], data[1], data[2],
                       f_humidity, f_temperature, time.time()]

            self.dht_callbacks[data[1]](message)

    def _digital_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for Digital Messages.

        :param data: digital message

        &#34;&#34;&#34;
        pin = data[0]
        value = data[1]

        time_stamp = time.time()
        if self.digital_callbacks[pin]:
            message = [PrivateConstants.DIGITAL_REPORT, pin, value, time_stamp]
            self.digital_callbacks[pin](message)

    def _firmware_message(self, data):
        &#34;&#34;&#34;
        Telemetrix4Arduino firmware version message

        :param data: data[0] = major number, data[1] = minor number.

                               data[2] = patch number
        &#34;&#34;&#34;

        self.firmware_version = [data[0], data[1], data[2]]

    def _i2c_read_report(self, data):
        &#34;&#34;&#34;
        Execute callback for i2c reads.

        :param data: [I2C_READ_REPORT, i2c_port, number of bytes read, address, register, bytes read..., time-stamp]
        &#34;&#34;&#34;

        # we receive [# data bytes, address, register, data bytes]
        # number of bytes of data returned

        # data[0] = number of bytes
        # data[1] = i2c_port
        # data[2] = number of bytes returned
        # data[3] = address
        # data[4] = register
        # data[5] ... all the data bytes

        cb_list = [PrivateConstants.I2C_READ_REPORT, data[0], data[1]] + data[2:]
        cb_list.append(time.time())

        if cb_list[1]:
            self.i2c_callback2(cb_list)
        else:
            self.i2c_callback(cb_list)

    def _i2c_too_few(self, data):
        &#34;&#34;&#34;
        I2c reports too few bytes received

        :param data: data[0] = device address
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;i2c too few bytes received from i2c port {data[0]} i2c address {data[1]}&#39;)

    def _i2c_too_many(self, data):
        &#34;&#34;&#34;
        I2c reports too few bytes received

        :param data: data[0] = device address
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;i2c too many bytes received from i2c port {data[0]} i2c address {data[1]}&#39;)

    def _i_am_here(self, data):
        &#34;&#34;&#34;
        Reply to are_u_there message
        :param data: arduino id
        &#34;&#34;&#34;
        self.reported_arduino_id = data[0]

    def _one_wire_report(self, report):
        print(report)

    def _spi_report(self, report):

        cb_list = [PrivateConstants.SPI_REPORT, report[0]] + report[1:]

        cb_list.append(time.time())

        self.spi_callback(cb_list)

    def _onewire_report(self, report):
        cb_list = [PrivateConstants.ONE_WIRE_REPORT, report[0]] + report[1:]
        self.onewire_callback(cb_list)


    def _report_debug_data(self, data):
        &#34;&#34;&#34;
        Print debug data sent from Arduino
        :param data: data[0] is a byte followed by 2
                     bytes that comprise an integer
        :return:
        &#34;&#34;&#34;
        value = (data[1] &lt;&lt; 8) + data[2]
        print(f&#39;DEBUG ID: {data[0]} Value: {value}&#39;)

    def _report_loop_data(self, data):
        &#34;&#34;&#34;
        Print data that was looped back
        :param data: byte of loop back data
        :return:
        &#34;&#34;&#34;
        if self.loop_back_callback:
            self.loop_back_callback(data)

    def _send_command(self, command):
        &#34;&#34;&#34;
        This is a private utility method.


        :param command:  command data in the form of a list

        &#34;&#34;&#34;
        # the length of the list is added at the head
        command.insert(0, len(command))
        send_message = bytes(command)

        if self.serial_port:
            try:
                self.serial_port.write(send_message)
            except SerialException:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;write fail in _send_command&#39;)
        elif self.ip_address:
            self.sock.sendall(send_message)
        else:
            raise RuntimeError(&#39;No serial port or ip address set.&#39;)

    def _servo_unavailable(self, report):
        &#34;&#34;&#34;
        Message if no servos are available for use.
        :param report: pin number
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;Servo Attach For Pin {report[0]} Failed: No Available Servos&#39;)

    def _sonar_distance_report(self, report):
        &#34;&#34;&#34;

        :param report: data[0] = trigger pin, data[1] and data[2] = distance

        callback report format: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]
        &#34;&#34;&#34;

        # get callback from pin number
        cb = self.sonar_callbacks[report[0]]

        # build report data
        cb_list = [PrivateConstants.SONAR_DISTANCE, report[0],
                   ((report[1] &lt;&lt; 8) + report[2]), time.time()]

        cb(cb_list)

    def _run_threads(self):
        self.run_event.set()

    def _is_running(self):
        return self.run_event.is_set()

    def _stop_threads(self):
        self.run_event.clear()

    def _reporter(self):
        &#34;&#34;&#34;
        This is the reporter thread. It continuously pulls data from
        the deque. When a full message is detected, that message is
        processed.
        &#34;&#34;&#34;
        self.run_event.wait()

        while self._is_running() and not self.shutdown_flag:
            if len(self.the_deque):
                # response_data will be populated with the received data for the report
                response_data = []
                packet_length = self.the_deque.popleft()
                if packet_length:
                    # get all the data for the report and place it into response_data
                    for i in range(packet_length):
                        while not len(self.the_deque):
                            time.sleep(self.sleep_tune)
                        data = self.the_deque.popleft()
                        response_data.append(data)

                    # print(response_data)

                    # get the report type and look up its dispatch method
                    # here we pop the report type off of response_data
                    report_type = response_data.pop(0)
                    # print(report_type)

                    # retrieve the report handler from the dispatch table
                    dispatch_entry = self.report_dispatch.get(report_type)

                    # if there is additional data for the report,
                    # it will be contained in response_data
                    # noinspection PyArgumentList
                    dispatch_entry(response_data)
                    continue
                else:
                    if self.shutdown_on_exception:
                        self.shutdown()
                    raise RuntimeError(
                        &#39;A report with a packet length of zero was received.&#39;)
            else:
                time.sleep(self.sleep_tune)

    def _serial_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()

        # Don&#39;t start this thread if using a tcp/ip transport
        if self.ip_address:
            return

        while self._is_running() and not self.shutdown_flag:
            # we can get an OSError: [Errno9] Bad file descriptor when shutting down
            # just ignore it
            try:
                if self.serial_port.inWaiting():
                    c = self.serial_port.read()
                    self.the_deque.append(ord(c))
                    # print(ord(c))
                else:
                    time.sleep(self.sleep_tune)
                    # continue
            except OSError:
                pass

    def _tcp_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()

        # Start this thread only if ip_address is set

        if self.ip_address:

            while self._is_running() and not self.shutdown_flag:
                try:
                    payload = self.sock.recv(1)
                    self.the_deque.append(ord(payload))
                except Exception:
                    pass
        else:
            return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="telemetrix.telemetrix.Telemetrix.analog_write"><code class="name flex">
<span>def <span class="ident">analog_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the specified pin to the specified value.</p>
<p>:param pin: arduino pin number</p>
<p>:param value: pin value (maximum 16 bits)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analog_write(self, pin, value):
    &#34;&#34;&#34;
    Set the specified pin to the specified value.

    :param pin: arduino pin number

    :param value: pin value (maximum 16 bits)

    &#34;&#34;&#34;
    value_msb = value &gt;&gt; 8
    value_lsb = value &amp; 0xff
    command = [PrivateConstants.ANALOG_WRITE, pin, value_msb, value_lsb]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.digital_write"><code class="name flex">
<span>def <span class="ident">digital_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the specified pin to the specified value.</p>
<p>:param pin: arduino pin number</p>
<p>:param value: pin value (1 or 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digital_write(self, pin, value):
    &#34;&#34;&#34;
    Set the specified pin to the specified value.

    :param pin: arduino pin number

    :param value: pin value (1 or 0)

    &#34;&#34;&#34;

    command = [PrivateConstants.DIGITAL_WRITE, pin, value]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.disable_all_reporting"><code class="name flex">
<span>def <span class="ident">disable_all_reporting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable reporting for all digital and analog input pins</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_all_reporting(self):
    &#34;&#34;&#34;
    Disable reporting for all digital and analog input pins
    &#34;&#34;&#34;
    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_DISABLE_ALL, 0]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.disable_analog_reporting"><code class="name flex">
<span>def <span class="ident">disable_analog_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables analog reporting for a single analog pin.</p>
<p>:param pin: Analog pin number. For example for A0, the number is 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_analog_reporting(self, pin):
    &#34;&#34;&#34;
    Disables analog reporting for a single analog pin.

    :param pin: Analog pin number. For example for A0, the number is 0.

    &#34;&#34;&#34;
    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_ANALOG_DISABLE, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.disable_digital_reporting"><code class="name flex">
<span>def <span class="ident">disable_digital_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables digital reporting for a single digital input.</p>
<p>:param pin: Pin number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_digital_reporting(self, pin):
    &#34;&#34;&#34;
    Disables digital reporting for a single digital input.

    :param pin: Pin number.

    &#34;&#34;&#34;
    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_DIGITAL_DISABLE, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.enable_analog_reporting"><code class="name flex">
<span>def <span class="ident">enable_analog_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables analog reporting for the specified pin.</p>
<p>:param pin: Analog pin number. For example for A0, the number is 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_analog_reporting(self, pin):
    &#34;&#34;&#34;
    Enables analog reporting for the specified pin.

    :param pin: Analog pin number. For example for A0, the number is 0.


    &#34;&#34;&#34;
    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_ANALOG_ENABLE, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.enable_digital_reporting"><code class="name flex">
<span>def <span class="ident">enable_digital_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable reporting on the specified digital pin.</p>
<p>:param pin: Pin number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_digital_reporting(self, pin):
    &#34;&#34;&#34;
    Enable reporting on the specified digital pin.

    :param pin: Pin number.
    &#34;&#34;&#34;

    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_DIGITAL_ENABLE, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.i2c_read"><code class="name flex">
<span>def <span class="ident">i2c_read</span></span>(<span>self, address, register, number_of_bytes, callback=None, i2c_port=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified number of bytes from the specified register for
the i2c device.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Required callback function to report i2c data as a
result of read command</p>
<p>:param i2c_port: 0 = default, 1 = secondary</p>
<p>callback returns a data list:
[I2C_READ_REPORT, address, register, count of data bytes, data bytes, time-stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_read(self, address, register, number_of_bytes,
             callback=None, i2c_port=0):
    &#34;&#34;&#34;
    Read the specified number of bytes from the specified register for
    the i2c device.


    :param address: i2c device address

    :param register: i2c register (or None if no register selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Required callback function to report i2c data as a
               result of read command

   :param i2c_port: 0 = default, 1 = secondary


    callback returns a data list:
    [I2C_READ_REPORT, address, register, count of data bytes, data bytes, time-stamp]

    &#34;&#34;&#34;

    self._i2c_read_request(address, register, number_of_bytes,
                           callback=callback, i2c_port=i2c_port)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.i2c_read_restart_transmission"><code class="name flex">
<span>def <span class="ident">i2c_read_restart_transmission</span></span>(<span>self, address, register, number_of_bytes, callback=None, i2c_port=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified number of bytes from the specified register for
the i2c device. This restarts the transmission after the read. It is
required for some i2c devices such as the MMA8452Q accelerometer.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register
selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Required callback function to report i2c data as a
result of read command</p>
<p>:param i2c_port: 0 = default 1 = secondary</p>
<p>callback returns a data list:</p>
<p>[I2C_READ_REPORT, address, register, count of data bytes, data bytes, time-stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_read_restart_transmission(self, address, register,
                                  number_of_bytes,
                                  callback=None, i2c_port=0):
    &#34;&#34;&#34;
    Read the specified number of bytes from the specified register for
    the i2c device. This restarts the transmission after the read. It is
    required for some i2c devices such as the MMA8452Q accelerometer.


    :param address: i2c device address

    :param register: i2c register (or None if no register
                                                selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Required callback function to report i2c data as a
               result of read command

   :param i2c_port: 0 = default 1 = secondary


    callback returns a data list:

    [I2C_READ_REPORT, address, register, count of data bytes, data bytes, time-stamp]

    &#34;&#34;&#34;

    self._i2c_read_request(address, register, number_of_bytes,
                           stop_transmission=False,
                           callback=callback, i2c_port=i2c_port)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.i2c_write"><code class="name flex">
<span>def <span class="ident">i2c_write</span></span>(<span>self, address, args, i2c_port=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to an i2c device.</p>
<p>:param address: i2c device address</p>
<p>:param i2c_port: 0= port 1, 1 = port 2</p>
<p>:param args: A variable number of bytes to be sent to the device
passed in as a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_write(self, address, args, i2c_port=0):
    &#34;&#34;&#34;
    Write data to an i2c device.

    :param address: i2c device address

    :param i2c_port: 0= port 1, 1 = port 2

    :param args: A variable number of bytes to be sent to the device
                 passed in as a list

    &#34;&#34;&#34;
    if not i2c_port:
        if not self.i2c_1_active:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                &#39;I2C Write: set_pin_mode i2c never called for i2c port 1.&#39;)

    if i2c_port:
        if not self.i2c_2_active:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                &#39;I2C Write: set_pin_mode i2c never called for i2c port 2.&#39;)

    command = [PrivateConstants.I2C_WRITE, len(args), address, i2c_port]

    for item in args:
        command.append(item)

    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.loop_back"><code class="name flex">
<span>def <span class="ident">loop_back</span></span>(<span>self, start_character, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a debugging method to send a character to the
Arduino device, and have the device loop it back.</p>
<p>:param start_character: The character to loop back. It should be
an integer.</p>
<p>:param callback: Looped back character will appear in the callback method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_back(self, start_character, callback=None):
    &#34;&#34;&#34;
    This is a debugging method to send a character to the
    Arduino device, and have the device loop it back.

    :param start_character: The character to loop back. It should be
                            an integer.

    :param callback: Looped back character will appear in the callback method

    &#34;&#34;&#34;
    command = [PrivateConstants.LOOP_COMMAND, ord(start_character)]
    self.loop_back_callback = callback
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.onewire_crc8"><code class="name flex">
<span>def <span class="ident">onewire_crc8</span></span>(<span>self, address_list, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a CRC check on an array of data.
:param address_list:</p>
<p>:param callback: required
function to report a onewire device address</p>
<p>callback returns a data list:
[ONEWIRE_REPORT, ONEWIRE_CRC8=32, CRC, time-stamp]</p>
<p>ONEWIRE_REPORT = 14</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onewire_crc8(self, address_list, callback=None):
    &#34;&#34;&#34;
    Compute a CRC check on an array of data.
    :param address_list:

    :param callback: required  function to report a onewire device address

    callback returns a data list:
    [ONEWIRE_REPORT, ONEWIRE_CRC8=32, CRC, time-stamp]

    ONEWIRE_REPORT = 14

    &#34;&#34;&#34;

    if not self.onewire_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;onewire_crc8: OneWire interface is not enabled.&#39;)

    if not callback:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;onewire_crc8 A Callback must be specified&#39;)

    if type(address_list) is not list:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;onewire_crc8: address list must be a list.&#39;)

    self.onewire_callback = callback

    address_length = len(address_list)

    command = [PrivateConstants.ONE_WIRE_CRC8, address_length - 1]

    for data in address_list:
        command.append(data)

    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.onewire_read"><code class="name flex">
<span>def <span class="ident">onewire_read</span></span>(<span>self, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a byte from the onewire device
:param callback: required
function to report onewire data as a
result of read command</p>
<p>callback returns a data list:
[ONEWIRE_REPORT, ONEWIRE_READ=29, data byte, time-stamp]</p>
<p>ONEWIRE_REPORT = 14</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onewire_read(self, callback=None):
    &#34;&#34;&#34;
    Read a byte from the onewire device
    :param callback: required  function to report onewire data as a
               result of read command


    callback returns a data list:
    [ONEWIRE_REPORT, ONEWIRE_READ=29, data byte, time-stamp]

    ONEWIRE_REPORT = 14
    &#34;&#34;&#34;
    if not self.onewire_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;onewire_read: OneWire interface is not enabled.&#39;)

    if not callback:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;onewire_read A Callback must be specified&#39;)

    self.onewire_callback = callback

    command = [PrivateConstants.ONE_WIRE_READ]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.onewire_reset"><code class="name flex">
<span>def <span class="ident">onewire_reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the onewire device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onewire_reset(self):
    &#34;&#34;&#34;
    Reset the onewire device
    &#34;&#34;&#34;
    if not self.onewire_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;onewire_reset: OneWire interface is not enabled.&#39;)
    command = [PrivateConstants.ONE_WIRE_RESET]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.onewire_reset_search"><code class="name flex">
<span>def <span class="ident">onewire_reset_search</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Begin a new search. The next use of search will begin at the first device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onewire_reset_search(self):
    &#34;&#34;&#34;
    Begin a new search. The next use of search will begin at the first device
    &#34;&#34;&#34;

    if not self.onewire_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;onewire_reset_serach: OneWire interface is not enabled.&#39;)
    else:
        command = [PrivateConstants.ONE_WIRE_RESET_SEARCH]
        self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.onewire_search"><code class="name flex">
<span>def <span class="ident">onewire_search</span></span>(<span>self, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for the next device. The device address will returned in the callback.
If a device is found, the 8 byte address is contained in the callback.
If no more devices are found, the address returned contains all elements set
to 0xff.</p>
<p>:param callback: required
function to report a onewire device address</p>
<p>callback returns a data list:
[ONEWIRE_REPORT, ONEWIRE_SEARCH=31, 8 byte address, time-stamp]</p>
<p>ONEWIRE_REPORT = 14</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onewire_search(self, callback=None):
    &#34;&#34;&#34;
    Search for the next device. The device address will returned in the callback.
    If a device is found, the 8 byte address is contained in the callback.
    If no more devices are found, the address returned contains all elements set
    to 0xff.

    :param callback: required  function to report a onewire device address

    callback returns a data list:
    [ONEWIRE_REPORT, ONEWIRE_SEARCH=31, 8 byte address, time-stamp]

    ONEWIRE_REPORT = 14
    &#34;&#34;&#34;
    if not self.onewire_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;onewire_search: OneWire interface is not enabled.&#39;)

    if not callback:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;onewire_read A Callback must be specified&#39;)

    self.onewire_callback = callback

    command = [PrivateConstants.ONE_WIRE_SEARCH]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.onewire_select"><code class="name flex">
<span>def <span class="ident">onewire_select</span></span>(<span>self, device_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Select a device based on its address
:param device_address: A bytearray of 8 bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onewire_select(self, device_address):
    &#34;&#34;&#34;
    Select a device based on its address
    :param device_address: A bytearray of 8 bytes
    &#34;&#34;&#34;
    if not self.onewire_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;onewire_select: OneWire interface is not enabled.&#39;)

    if type(device_address) is not bytearray:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;onewire_select: device address must be an array of 8 &#39;
                           &#39;bytes.&#39;)

    if len(device_address) != 8:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;onewire_select: device address must be an array of 8 &#39;
                           &#39;bytes.&#39;)
    command = [PrivateConstants.ONE_WIRE_SELECT]
    for data in device_address:
        command.append(data)
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.onewire_skip"><code class="name flex">
<span>def <span class="ident">onewire_skip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Skip the device selection. This only works if you have a
single device, but you can avoid searching and use this to
immediately access your device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onewire_skip(self):
    &#34;&#34;&#34;
    Skip the device selection. This only works if you have a
    single device, but you can avoid searching and use this to
    immediately access your device.
    &#34;&#34;&#34;
    if not self.onewire_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;onewire_skip: OneWire interface is not enabled.&#39;)

    command = [PrivateConstants.ONE_WIRE_SKIP]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.onewire_write"><code class="name flex">
<span>def <span class="ident">onewire_write</span></span>(<span>self, data, power=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a to the onewire device. If 'power' is one then the wire is held high at
the end for parasitically powered devices. You are responsible
for eventually de-powering it by calling another read or write.</p>
<p>:param data: byte to write.
:param power: power control (see above)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onewire_write(self, data, power=0):
    &#34;&#34;&#34;
    Write a to the onewire device. If &#39;power&#39; is one then the wire is held high at
    the end for parasitically powered devices. You are responsible
    for eventually de-powering it by calling another read or write.

    :param data: byte to write.
    :param power: power control (see above)
    &#34;&#34;&#34;
    if not self.onewire_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;onewire_write: OneWire interface is not enabled.&#39;)
    if 0 &lt; data &lt; 255:
        command = [PrivateConstants.ONE_WIRE_WRITE, data, power]
        self._send_command(command)
    else:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;onewire_write: Data must be no larger than 255&#39;)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.servo_detach"><code class="name flex">
<span>def <span class="ident">servo_detach</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Detach a servo for reuse</p>
<p>:param pin_number: attached pin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def servo_detach(self, pin_number):
    &#34;&#34;&#34;
    Detach a servo for reuse

    :param pin_number: attached pin

    &#34;&#34;&#34;
    command = [PrivateConstants.SERVO_DETACH, pin_number]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.servo_write"><code class="name flex">
<span>def <span class="ident">servo_write</span></span>(<span>self, pin_number, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a servo attached to a pin to a given angle.</p>
<p>:param pin_number: pin</p>
<p>:param angle: angle (0-180)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def servo_write(self, pin_number, angle):
    &#34;&#34;&#34;

    Set a servo attached to a pin to a given angle.

    :param pin_number: pin

    :param angle: angle (0-180)

    &#34;&#34;&#34;
    command = [PrivateConstants.SERVO_WRITE, pin_number, angle]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_analog_scan_interval"><code class="name flex">
<span>def <span class="ident">set_analog_scan_interval</span></span>(<span>self, interval)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the analog scanning interval.</p>
<p>:param interval: value of 0 - 255 - milliseconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_analog_scan_interval(self, interval):
    &#34;&#34;&#34;
    Set the analog scanning interval.

    :param interval: value of 0 - 255 - milliseconds
    &#34;&#34;&#34;

    if 0 &lt;= interval &lt;= 255:
        command = [PrivateConstants.SET_ANALOG_SCANNING_INTERVAL, interval]
        self._send_command(command)
    else:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;Analog interval must be between 0 and 255&#39;)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_analog_input"><code class="name flex">
<span>def <span class="ident">set_pin_mode_analog_input</span></span>(<span>self, pin_number, differential=0, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as an analog input.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param differential: difference in previous to current value before
report will be generated</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for analog input pins = 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_analog_input(self, pin_number, differential=0, callback=None):
    &#34;&#34;&#34;
    Set a pin as an analog input.

    :param pin_number: arduino pin number

    :param differential: difference in previous to current value before
                         report will be generated

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for analog input pins = 2

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.AT_ANALOG, differential,
                       callback)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_analog_output"><code class="name flex">
<span>def <span class="ident">set_pin_mode_analog_output</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a pwm (analog output) pin.</p>
<p>:param pin_number:arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_analog_output(self, pin_number):
    &#34;&#34;&#34;
    Set a pin as a pwm (analog output) pin.

    :param pin_number:arduino pin number

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_dht"><code class="name flex">
<span>def <span class="ident">set_pin_mode_dht</span></span>(<span>self, pin, callback=None, dht_type=22)</span>
</code></dt>
<dd>
<div class="desc"><p>:param pin: connection pin</p>
<p>:param callback: callback function</p>
<p>:param dht_type: either 22 for DHT22 or 11 for DHT11</p>
<p>Error Callback: [DHT REPORT Type, DHT_ERROR_NUMBER, PIN, DHT_TYPE, Time]</p>
<p>Valid Data Callback: DHT REPORT Type, DHT_DATA=, PIN, DHT_TYPE, Humidity,
Temperature,
Time]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_dht(self, pin, callback=None, dht_type=22):
    &#34;&#34;&#34;

    :param pin: connection pin

    :param callback: callback function

    :param dht_type: either 22 for DHT22 or 11 for DHT11

    Error Callback: [DHT REPORT Type, DHT_ERROR_NUMBER, PIN, DHT_TYPE, Time]

    Valid Data Callback: DHT REPORT Type, DHT_DATA=, PIN, DHT_TYPE, Humidity,
    Temperature,
    Time]

    &#34;&#34;&#34;

    if not callback:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;set_pin_mode_dht: A Callback must be specified&#39;)

    if self.dht_count &lt; PrivateConstants.MAX_DHTS - 1:
        self.dht_callbacks[pin] = callback
        self.dht_count += 1

        if dht_type != 22 and dht_type != 11:
            dht_type = 22

        command = [PrivateConstants.DHT_NEW, pin, dht_type]
        self._send_command(command)
    else:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;Maximum Number Of DHTs Exceeded - set_pin_mode_dht fails for pin {pin}&#39;)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_input"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_input</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins = 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_input(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input.

    :param pin_number: arduino pin number

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins = 0

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT, callback=callback)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_input_pullup"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_input_pullup</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input with pullup enabled.</p>
<p>:param pin_number: arduino pin number</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins with pullups enabled = 11</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input with pullup enabled.

    :param pin_number: arduino pin number

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins with pullups enabled = 11

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULLUP, callback)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_output"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_output</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital output pin.</p>
<p>:param pin_number: arduino pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_output(self, pin_number):
    &#34;&#34;&#34;
    Set a pin as a digital output pin.

    :param pin_number: arduino pin number
    &#34;&#34;&#34;

    self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_i2c"><code class="name flex">
<span>def <span class="ident">set_pin_mode_i2c</span></span>(<span>self, i2c_port=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish the standard Arduino i2c pins for i2c utilization.</p>
<p>:param i2c_port: 0 = i2c1, 1 = i2c2</p>
<p>NOTES: 1. THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
2. Callbacks are set within the individual i2c read methods of this
API.</p>
<pre><code>  See i2c_read, or i2c_read_restart_transmission.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_i2c(self, i2c_port=0):
    &#34;&#34;&#34;
    Establish the standard Arduino i2c pins for i2c utilization.

    :param i2c_port: 0 = i2c1, 1 = i2c2

    NOTES: 1. THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE
           2. Callbacks are set within the individual i2c read methods of this
          API.

          See i2c_read, or i2c_read_restart_transmission.

    &#34;&#34;&#34;
    # test for i2c port 2
    if i2c_port:
        # if not previously activated set it to activated
        # and the send a begin message for this port
        if not self.i2c_2_active:
            self.i2c_2_active = True
        else:
            return
    # port 1
    else:
        if not self.i2c_1_active:
            self.i2c_1_active = True
        else:
            return

    command = [PrivateConstants.I2C_BEGIN, i2c_port]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_one_wire"><code class="name flex">
<span>def <span class="ident">set_pin_mode_one_wire</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the one wire serial bus.
:param pin: Data pin used with the OneWire device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_one_wire(self, pin):
    &#34;&#34;&#34;
    Initialize the one wire serial bus.
    :param pin: Data pin used with the OneWire device
    &#34;&#34;&#34;
    self.onewire_enabled = True
    command = [PrivateConstants.ONE_WIRE_INIT, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_servo"><code class="name flex">
<span>def <span class="ident">set_pin_mode_servo</span></span>(<span>self, pin_number, min_pulse=544, max_pulse=2400)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a pin to a servo motor</p>
<p>:param pin_number: pin</p>
<p>:param min_pulse: minimum pulse width</p>
<p>:param max_pulse: maximum pulse width</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_servo(self, pin_number, min_pulse=544, max_pulse=2400):
    &#34;&#34;&#34;

    Attach a pin to a servo motor

    :param pin_number: pin

    :param min_pulse: minimum pulse width

    :param max_pulse: maximum pulse width

    &#34;&#34;&#34;
    minv = (min_pulse).to_bytes(2, byteorder=&#34;big&#34;)
    maxv = (max_pulse).to_bytes(2, byteorder=&#34;big&#34;)

    command = [PrivateConstants.SERVO_ATTACH, pin_number,
               minv[0], minv[1], maxv[0], maxv[1]]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_sonar"><code class="name flex">
<span>def <span class="ident">set_pin_mode_sonar</span></span>(<span>self, trigger_pin, echo_pin, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>:param trigger_pin:</p>
<p>:param echo_pin:</p>
<p>:param callback: callback</p>
<p>callback data: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_sonar(self, trigger_pin, echo_pin,
                       callback=None):
    &#34;&#34;&#34;

    :param trigger_pin:

    :param echo_pin:

    :param callback: callback

    callback data: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]

    &#34;&#34;&#34;

    if not callback:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;set_pin_mode_sonar: A Callback must be specified&#39;)

    if self.sonar_count &lt; PrivateConstants.MAX_SONARS - 1:
        self.sonar_callbacks[trigger_pin] = callback
        self.sonar_count += 1

        command = [PrivateConstants.SONAR_NEW, trigger_pin, echo_pin]
        self._send_command(command)
    else:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;Maximum Number Of Sonars Exceeded - set_pin_mode_sonar fails for pin {trigger_pin}&#39;)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.set_pin_mode_spi"><code class="name flex">
<span>def <span class="ident">set_pin_mode_spi</span></span>(<span>self, chip_select_list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify the list of chip select pins.</p>
<p>Standard Arduino MISO, MOSI and CLK pins are used for the board in use.</p>
<p>Chip Select is any digital output capable pin.</p>
<p>:param chip_select_list: this is a list of pins to be used for chip select.
The pins will be configured as output, and set to high
ready to be used for chip select.
NOTE: You must specify the chips select pins here!</p>
<p>command message: [command, number of cs pins, [cs pins&hellip;]]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_spi(self, chip_select_list=None):
    &#34;&#34;&#34;
    Specify the list of chip select pins.

    Standard Arduino MISO, MOSI and CLK pins are used for the board in use.

    Chip Select is any digital output capable pin.

    :param chip_select_list: this is a list of pins to be used for chip select.
                       The pins will be configured as output, and set to high
                       ready to be used for chip select.
                       NOTE: You must specify the chips select pins here!


    command message: [command, number of cs pins, [cs pins...]]
    &#34;&#34;&#34;

    if type(chip_select_list) != list:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;chip_select_list must be in the form of a list&#39;)
    if not chip_select_list:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;Chip select pins were not specified&#39;)

    self.spi_enabled = True

    command = [PrivateConstants.SPI_INIT, len(chip_select_list)]

    for pin in chip_select_list:
        command.append(pin)
        self.cs_pins_enabled.append(pin)
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method attempts an orderly shutdown
If any exceptions are thrown, they are ignored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self):
    &#34;&#34;&#34;
    This method attempts an orderly shutdown
    If any exceptions are thrown, they are ignored.
    &#34;&#34;&#34;
    self.shutdown_flag = True

    self._stop_threads()

    try:
        command = [PrivateConstants.STOP_ALL_REPORTS]
        self._send_command(command)
        time.sleep(.5)

        if self.ip_address:
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
                self.sock.close()
            except Exception:
                pass
        else:
            try:
                self.serial_port.reset_input_buffer()
                self.serial_port.close()

            except (RuntimeError, SerialException, OSError):
                # ignore error on shutdown
                pass
    except Exception:
        raise RuntimeError(&#39;Shutdown failed - could not send stop streaming message&#39;)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.spi_cs_control"><code class="name flex">
<span>def <span class="ident">spi_cs_control</span></span>(<span>self, chip_select_pin, select)</span>
</code></dt>
<dd>
<div class="desc"><p>Control an SPI chip select line
:param chip_select_pin: pin connected to CS</p>
<p>:param select: 0=select, 1=deselect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_cs_control(self, chip_select_pin, select):
    &#34;&#34;&#34;
    Control an SPI chip select line
    :param chip_select_pin: pin connected to CS

    :param select: 0=select, 1=deselect
    &#34;&#34;&#34;
    if not self.spi_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;spi_cs_control: SPI interface is not enabled.&#39;)

    if chip_select_pin not in self.cs_pins_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;spi_cs_control: chip select pin never enabled.&#39;)
    command = [PrivateConstants.SPI_CS_CONTROL, chip_select_pin, select]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.spi_read_blocking"><code class="name flex">
<span>def <span class="ident">spi_read_blocking</span></span>(<span>self, register_selection, number_of_bytes_to_read, call_back=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified number of bytes from the specified SPI port and
call the callback function with the reported data.</p>
<p>:param register_selection: Register to be selected for read.</p>
<p>:param number_of_bytes_to_read: Number of bytes to read</p>
<p>:param call_back: Required callback function to report spi data as a
result of read command</p>
<p>callback returns a data list:
[SPI_READ_REPORT, count of data bytes read, data bytes, time-stamp]</p>
<p>SPI_READ_REPORT = 13</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_read_blocking(self, register_selection, number_of_bytes_to_read,
                      call_back=None):
    &#34;&#34;&#34;
    Read the specified number of bytes from the specified SPI port and
    call the callback function with the reported data.

    :param register_selection: Register to be selected for read.

    :param number_of_bytes_to_read: Number of bytes to read

    :param call_back: Required callback function to report spi data as a
               result of read command


    callback returns a data list:
    [SPI_READ_REPORT, count of data bytes read, data bytes, time-stamp]

    SPI_READ_REPORT = 13

    &#34;&#34;&#34;

    if not self.spi_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;spi_read_blocking: SPI interface is not enabled.&#39;)

    if not call_back:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;spi_read_blocking: A Callback must be specified&#39;)

    self.spi_callback = call_back

    command = [PrivateConstants.SPI_READ_BLOCKING, number_of_bytes_to_read,
               register_selection]

    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.spi_set_format"><code class="name flex">
<span>def <span class="ident">spi_set_format</span></span>(<span>self, clock_divisor, bit_order, data_mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure how the SPI serializes and de-serializes data on the wire.</p>
<p>See Arduino SPI reference materials for details.</p>
<p>:param clock_divisor:</p>
<p>:param bit_order:
LSBFIRST = 0</p>
<pre><code>                MSBFIRST = 1 (default)
</code></pre>
<p>:param data_mode:
SPI_MODE0 = 0x00 (default)</p>
<pre><code>                SPI_MODE1  = 0x04

                SPI_MODE2 = 0x08

                SPI_MODE3 = 0x0C
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_set_format(self, clock_divisor, bit_order, data_mode):
    &#34;&#34;&#34;
    Configure how the SPI serializes and de-serializes data on the wire.

    See Arduino SPI reference materials for details.

    :param clock_divisor:

    :param bit_order:   LSBFIRST = 0

                        MSBFIRST = 1 (default)

    :param data_mode:   SPI_MODE0 = 0x00 (default)

                        SPI_MODE1  = 0x04

                        SPI_MODE2 = 0x08

                        SPI_MODE3 = 0x0C

    &#34;&#34;&#34;

    if not self.spi_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;spi_set_format: SPI interface is not enabled.&#39;)

    command = [PrivateConstants.SPI_SET_FORMAT, clock_divisor, bit_order,
               data_mode]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix.telemetrix.Telemetrix.spi_write_blocking"><code class="name flex">
<span>def <span class="ident">spi_write_blocking</span></span>(<span>self, bytes_to_write)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a list of bytes to the SPI device.</p>
<p>:param bytes_to_write: A list of bytes to write. This must be in the form of a
list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spi_write_blocking(self, bytes_to_write):
    &#34;&#34;&#34;
    Write a list of bytes to the SPI device.

    :param bytes_to_write: A list of bytes to write. This must be in the form of a
    list.

    &#34;&#34;&#34;

    if not self.spi_enabled:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(f&#39;spi_write_blocking: SPI interface is not enabled.&#39;)

    if type(bytes_to_write) is not list:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;spi_write_blocking: bytes_to_write must be a list.&#39;)

    command = [PrivateConstants.SPI_WRITE_BLOCKING, len(bytes_to_write)]

    for data in bytes_to_write:
        command.append(data)

    self._send_command(command)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="telemetrix" href="index.html">telemetrix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="telemetrix.telemetrix.Telemetrix" href="#telemetrix.telemetrix.Telemetrix">Telemetrix</a></code></h4>
<ul class="">
<li><code><a title="telemetrix.telemetrix.Telemetrix.analog_write" href="#telemetrix.telemetrix.Telemetrix.analog_write">analog_write</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.digital_write" href="#telemetrix.telemetrix.Telemetrix.digital_write">digital_write</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.disable_all_reporting" href="#telemetrix.telemetrix.Telemetrix.disable_all_reporting">disable_all_reporting</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.disable_analog_reporting" href="#telemetrix.telemetrix.Telemetrix.disable_analog_reporting">disable_analog_reporting</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.disable_digital_reporting" href="#telemetrix.telemetrix.Telemetrix.disable_digital_reporting">disable_digital_reporting</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.enable_analog_reporting" href="#telemetrix.telemetrix.Telemetrix.enable_analog_reporting">enable_analog_reporting</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.enable_digital_reporting" href="#telemetrix.telemetrix.Telemetrix.enable_digital_reporting">enable_digital_reporting</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.i2c_read" href="#telemetrix.telemetrix.Telemetrix.i2c_read">i2c_read</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.i2c_read_restart_transmission" href="#telemetrix.telemetrix.Telemetrix.i2c_read_restart_transmission">i2c_read_restart_transmission</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.i2c_write" href="#telemetrix.telemetrix.Telemetrix.i2c_write">i2c_write</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.loop_back" href="#telemetrix.telemetrix.Telemetrix.loop_back">loop_back</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.onewire_crc8" href="#telemetrix.telemetrix.Telemetrix.onewire_crc8">onewire_crc8</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.onewire_read" href="#telemetrix.telemetrix.Telemetrix.onewire_read">onewire_read</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.onewire_reset" href="#telemetrix.telemetrix.Telemetrix.onewire_reset">onewire_reset</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.onewire_reset_search" href="#telemetrix.telemetrix.Telemetrix.onewire_reset_search">onewire_reset_search</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.onewire_search" href="#telemetrix.telemetrix.Telemetrix.onewire_search">onewire_search</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.onewire_select" href="#telemetrix.telemetrix.Telemetrix.onewire_select">onewire_select</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.onewire_skip" href="#telemetrix.telemetrix.Telemetrix.onewire_skip">onewire_skip</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.onewire_write" href="#telemetrix.telemetrix.Telemetrix.onewire_write">onewire_write</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.servo_detach" href="#telemetrix.telemetrix.Telemetrix.servo_detach">servo_detach</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.servo_write" href="#telemetrix.telemetrix.Telemetrix.servo_write">servo_write</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_analog_scan_interval" href="#telemetrix.telemetrix.Telemetrix.set_analog_scan_interval">set_analog_scan_interval</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_analog_input" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_analog_input">set_pin_mode_analog_input</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_analog_output" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_analog_output">set_pin_mode_analog_output</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_dht" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_dht">set_pin_mode_dht</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_input" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_input">set_pin_mode_digital_input</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_input_pullup" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_input_pullup">set_pin_mode_digital_input_pullup</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_output" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_digital_output">set_pin_mode_digital_output</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_i2c" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_i2c">set_pin_mode_i2c</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_one_wire" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_one_wire">set_pin_mode_one_wire</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_servo" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_servo">set_pin_mode_servo</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_sonar" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_sonar">set_pin_mode_sonar</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.set_pin_mode_spi" href="#telemetrix.telemetrix.Telemetrix.set_pin_mode_spi">set_pin_mode_spi</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.shutdown" href="#telemetrix.telemetrix.Telemetrix.shutdown">shutdown</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.spi_cs_control" href="#telemetrix.telemetrix.Telemetrix.spi_cs_control">spi_cs_control</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.spi_read_blocking" href="#telemetrix.telemetrix.Telemetrix.spi_read_blocking">spi_read_blocking</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.spi_set_format" href="#telemetrix.telemetrix.Telemetrix.spi_set_format">spi_set_format</a></code></li>
<li><code><a title="telemetrix.telemetrix.Telemetrix.spi_write_blocking" href="#telemetrix.telemetrix.Telemetrix.spi_write_blocking">spi_write_blocking</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>